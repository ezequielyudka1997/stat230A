---
title: "230A - Group Project"
format: pdf
editor: source
---

```{r, message=FALSE}
library(tidyverse)
library(gridExtra)
library(MASS)
library(corrplot)
library(sandwich)
library(caret)
library(knitr)
library(kableExtra)
```

# Reading the Data In:

```{r}
zip_file_path <- "../processed_data.zip"
csv_file_inside_zip <- "processed_data.csv"
processed_data <- read.csv(unz(zip_file_path, csv_file_inside_zip), header = TRUE,
                 sep = ",") 
```

# Data Dictionary:

ST: State

DIVISION: Division code based on 2010 Census definitions Division code based on 2020 Census definitions 
0 .Puerto Rico 
1 .New England (Northeast region) 
2 .Middle Atlantic (Northeast region) 
3 .East North Central (Midwest region) 
4 .West North Central (Midwest region) 
5 .South Atlantic (South region) 
6 .East South Central (South region) 
7 .West South Central (South Region) 
8 .Mountain (West region)

AGEP: Age 
0 .Under 1 year 
1..99 .1 to 99 years (Top-coded)

ESR: 
1 .Civilian employed, at work 
2 .Civilian employed, with a job but not at work 
3 .Unemployed 
4 .Armed forces, at work 
5 .Armed forces, with a job but not at work

NATIVITY: Nativity 
1 .Native 
2 .Foreign born

CIT: Citizenship status 
1 .Born in the United States 
2 .Born in Puerto Rico, Guam, the U.S. Virgin Islands, or .Northern Marianas 
3 .Born abroad of U.S. citizen parent or parents 
4 .U.S. citizen by naturalization 
5 .Not a U.S. citizen

CITWP: Year of naturalization 
bbbb: N/A (Not eligible - not naturalized)

YOEP: Year of entry 
bbbb .N/A (Not eligible - Born in the US)

COW: Class of worker 
b .N/A (NILF who last worked more than 5 years ago or never worked) 
1 .Employee of a private for-profit company or business, or of an .individual, for wages, salary, or commissions 
2 .Employee of a private not-for-profit, tax-exempt, or .charitable organization 
3 .Local government employee (city, county, etc.) 
4 .State government employee 5 .Federal government employee 
6 .Self-employed in own not incorporated business, professional .practice, or farm 
7 .Self-employed in own incorporated business, professional .practice or farm 
8 .Working without pay in family business or farm 
9 .Unemployed and last worked 5 years ago or earlier or never .worked

Disability: 
1 .With a disability 
2 .Without a disability

ENG: Ability to speak English 
0 .speaks only English 
1 .Very well 
2 .Well 
3 .Not well 
4 .Not at all

PAP: Public assistance income past 12 months (use ADJINC to adjust to constant dollars) 
0 .None 
4..30000 .
\$4 to \$30000 (Rounded and top-coded)

FER: Gave birth to child within the past 12 months 
b .N/A (greater than 50 years/ male) 
1 .Yes 
2. No

MAR: Marital status 
1 .Married 
2 .Widowed 
3 .Divorced 
4 .Separated 
5 .Never married

SEX: Sex 
0 .Male 
1 .Female

SCH: School enrollment 
1 .No, has not attended in the last 3 months 
2 .Yes, public school or public college 
3 .Yes, private school or college or home school

SCHL: Educational attainment 
01 .No schooling completed 
02 .Nursery school, preschool 
03 .Kindergarten 
04 .Grade 1 
05 .Grade 2 
06 .Grade 3 
07 .Grade 4
08 .Grade 5
09 .Grade 6 
10 .Grade 7 
11 .Grade 8 
12 .Grade 9 
13 .Grade 10 
14 .Grade 11 
15 .12th grade - no diploma 
16 .Regular high school diploma 
17 .GED or alternative credential
18 .Some college, but less than 1 year 
19 .1 or more years of college credit, no degree
20 .Associate's degree 
21 .Bachelor's degree
22 .Master's degree 
23 .Professional degree beyond a bachelor's degree 
24 .Doctorate degree

PINCP: Total person's income (use ADJINC to adjust to constant dollars)
0 .None 
-19998 .Loss of \$19998 or more (Rounded and bottom-coded components)
-19997..-1 .Loss \$1 to \$19997 (Rounded components)
1..4209995 .\$1 to \$4209995 (Rounded and top-codedcomponents)

WAGP: Wages or salary income past 12 months (use ADJINC to adjust WAGP to constant dollars)
0 .None 
4..999999 .
\$4 to 999999 (Rounded and top-coded)

ANC: Ancestry recode
1 .Single
2 .Multiple
3 .Unclassified
4 .Not reported 
ANC1P: Recoded Detailed Ancestry - first entry 
ANC2P: Recoded Detailed Ancestry - second entry
POBP: Place of birth (Recode)

RAC1P: Recoded detailed race code 
1 .White alone 
2 .Black or African American alone
3 .American Indian alone 
4 .Alaska Native alone 
5 .American Indian and Alaska Native tribes specified; or American Indian or Alaska Native, not specified and no other races
6 .Asian alone 
7 .Native Hawaiian and Other Pacific Islander alone 
8 .Some Other Race alone 
9 .Two or More Races

PERNP: Total person's earnings (use ADJINC to adjust to constant dollars) 
0 .No earnings 
-10000 .Loss of \$10000 or more (Rounded and bottom-coded components) 
-9999..-1 .Loss \$1 to \$9999 (Rounded components) 
1..1999998 .\$1 to \$1999998 (Rounded and top-coded components)

HISP: Recoded detailed Hispanic origin

HINS4:Medicaid, Medical Assistance, or any kind of government-assistance plan for those with low incomes or a disability 
1 .Yes 
0 .No

Citizen: ifelse(CIT %in% c(1, 2, 3, 4), 1, 0) 
Foreign_born: ifelse(NATIVITY == 2, 1, 0)
High_School_Grad: ifelse(SCHL >= 16, 1, 0) 
Bachelors_Degree: ifelse(SCHL >= 21, 1, 0) 
Unemployed: ifelse(ESR == 3, 1, 0) 
HISP_dummy: ifelse(HISP == 1, 0, 1)
Years_in_US: 2022 - YOEP 
Years_naturalized: 2022 - CITWP Asian: ifelse(RAC1P ==6, 1, 0)
wb50birth: 1: Yes , 0: No/greater than 50 years/ male) 

# Cleaning: 

```{r}
processed_data <- processed_data %>%
  mutate(
    DIS = ifelse(DIS == 2, 0, 1),
    HINS4 = 1 - as.numeric(HINS4), 
    High_School_Grad = ifelse(SCHL >= 16, 1, 0))
```

```{r}
processed_data$ENG[is.na(processed_data$ENG)] <- 0
```

```{r}
processed_data$Years_naturalized[processed_data$Foreign_born == 0] <- 0
processed_data$Years_in_US[processed_data$Foreign_born == 0] <- 0
processed_data$Years_naturalized[processed_data$CIT == 5] <- 0
processed_data = processed_data%>%filter(CIT != 2)
processed_data$wb50birth <- processed_data$FER
processed_data$wb50birth[is.na(processed_data$FER) &
                         (processed_data$AGEP >= 50 | processed_data$SEX == 0)] <- 0
```

```{r}
processed_data2 = processed_data%>%filter(!(WAGP == 0 & Unemployed == 0))
```

```{r}
processed_data2 = processed_data2%>%mutate(immigrant = as.integer(CIT%in%c(4,5)))
```

```{r}
processed_data2 <- processed_data2%>%mutate(white_dummy = (RAC1P == 1),
                         asian_dummy = (RAC1P == 6),
                         black_dummy = (RAC1P == 2))
```


```{r}
immigrants_only = processed_data2%>%filter(CIT%in% c(4,5))
immigrants_only2 = immigrants_only%>%filter(RAC1P%in%c(1,2,6,8,9))
```

```{r}
non_immigrants = processed_data2%>%filter(immigrant==0, RAC1P%in%c(1,2,6,8,9))
```

# EDA Visualizations:

##wage densities

```{r}
a <- ggplot(processed_data2,aes(x = WAGP, y = ..density..)) + geom_density(color = 'cyan3', fill = 'cyan3', alpha = 0.5) + 
  labs(titles = "Distribution of Wages", x = "Wages Made in Last 12 Months", y = "Density (Proportion)")+ geom_vline(aes(xintercept=median(WAGP)),
            color="cyan3", linetype="dashed", linewidth=0.5, alpha = 0.5)
```

```{r}
# Calculate median wage for each citizenship group
median_data <- processed_data2 %>%
  group_by(Citizen) %>%
  summarise(median_wage = median(WAGP))

# Plot
wagecit <- ggplot(processed_data2, aes(x = WAGP, fill = factor(Citizen), color = factor(Citizen))) +
  geom_density(alpha = 0.5) +
  geom_vline(data = median_data, aes(xintercept = median_wage, color = factor(Citizen)), 
             linetype = "dashed", linewidth = 0.8, alpha = 0.8) +
  labs(title = "Distribution of Wages by Citizenship Status",
       x = "Wages Made in Last 12 Months",
       y = "Density (Proportion)",
       fill = "Citizen = 1",
       color = "Citizen = 1") +
  theme_minimal() 
```


```{r}
# Calculate median wage for each racial and citizenship group
median_data_race <- processed_data2 %>%
  filter(RAC1P %in% c(1, 2, 6, 8, 9)) %>%
  group_by(RAC1P, Citizen) %>%
  summarise(median_wage = median(WAGP))

# Plot
wagerace <- ggplot(processed_data2 %>% filter(RAC1P %in% c(1, 2, 6, 8, 9)), 
                   aes(x = WAGP, fill = factor(RAC1P), color = factor(RAC1P))) +
  geom_density(aes(y = ..density..), alpha = 0.5) +
  geom_vline(data = median_data_race, aes(xintercept = median_wage, color = factor(RAC1P)), 
             linetype = "dashed", linewidth = 0.5, alpha = 0.5) +
  facet_wrap(vars(factor(Citizen))) +
  labs(title = "Distribution of Wages by Race", subtitle = "Faceted by Citizenship Status",
       x = "Wages Made in Last 12 Months",
       y = "Density (Proportion)",
       color = "Race", fill = "Race") +
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
median_data_race <- processed_data2 %>%
  filter(RAC1P %in% c(1, 2, 6)) %>%
  group_by(RAC1P, Citizen) %>%
  summarise(median_wage = median(WAGP))

wagerace2 <- ggplot(processed_data2 %>% filter(RAC1P %in% c(1, 2, 6)), 
                    aes(x = WAGP, fill = factor(RAC1P), color = factor(RAC1P))) +
  geom_density(aes(y = ..density..), alpha = 0.5) +
  geom_vline(data = median_data_race, aes(xintercept = median_wage, color = factor(RAC1P)), 
             linetype = "dashed", linewidth = 0.5, alpha = 0.5) +
  facet_wrap(vars(factor(Citizen))) +
  labs(title = "Distribution of Wages by 3 Races", subtitle = "Faceted by Citizenship Status",
       x = "Wages Made in Last 12 Months",
       y = "Density (Proportion)",
       fill = "Race",
       color = "Race") +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

##log wage densities

```{r}
# Calculate median log(wage + 1) for the entire dataset
median_log_wage <- median(log(processed_data2$WAGP + 1))

# Plot
loga <- ggplot(processed_data2, aes(x = log(WAGP + 1), y = ..density..)) +
  geom_density(color = 'cyan3', fill = 'cyan3', alpha = 0.5) + 
  geom_vline(xintercept = median_log_wage, linetype = "dashed", linewidth = 0.5, alpha = 0.5) +
  labs(title = "Distribution of log(Wages + 1)", 
       x = "log(Wages + 1) Made in Last 12 Months", 
       y = "Density (Proportion)")

```

```{r}
# Calculate median log(wage + 1) for each citizenship group
median_data_citizen <- processed_data2 %>%
  group_by(Citizen) %>%
  summarise(median_log_wage = median(log(WAGP + 1)))

# Plot
logwagecit <- ggplot(processed_data2, aes(x = log(WAGP + 1), fill = factor(Citizen), color = factor(Citizen))) +
  geom_density(aes(y = ..density..), alpha = 0.5) +
  geom_vline(data = median_data_citizen, aes(xintercept = median_log_wage, color = factor(Citizen)), 
             linetype = "dashed", linewidth = 0.5, alpha = 0.5) +
  labs(title = "Distribution of log(Wages + 1) by Citizenship Status",
       x = "log(Wages + 1) Made in Last 12 Months",
       y = "Density (Proportion)", fill = "Citizen", color = "Citizen") +
  theme_minimal()
```

```{r}
# Calculate median log(wage + 1) for each racial and citizenship group
median_data_race <- processed_data2 %>%
  filter(RAC1P %in% c(1, 2, 6, 8, 9)) %>%
  group_by(RAC1P, Citizen) %>%
  summarise(median_log_wage = median(log(WAGP + 1)))

# Plot
logwagerace <- ggplot(processed_data2 %>% filter(RAC1P %in% c(1, 2, 6, 8, 9)), 
                      aes(x = log(WAGP + 1), fill = factor(RAC1P), color = factor(RAC1P))) +
  geom_density(aes(y = ..density..), alpha = 0.5) +
  geom_vline(data = median_data_race, aes(xintercept = median_log_wage, color = factor(RAC1P)), 
             linetype = "dashed", linewidth = 0.5, alpha = 0.5) +
  facet_wrap(vars(factor(Citizen))) +
  labs(title = "Distribution of log(Wages + 1) by Race", subtitle = "Faceted by Citizenship Status",
       x = "log(Wages + 1) Made in Last 12 Months",
       y = "Density (Proportion)",
       fill = "Race",
       color = "Race") +
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```

```{r}
# Calculate median log(wage + 1) for each racial and citizenship group
median_data_race <- processed_data2 %>%
  filter(RAC1P %in% c(1, 2, 6)) %>%
  group_by(RAC1P, Citizen) %>%
  summarise(median_log_wage = median(log(WAGP + 1)))

# Plot
logwagerace2 <- ggplot(processed_data2 %>% filter(RAC1P %in% c(1, 2, 6)), 
                       aes(x = log(WAGP + 1), fill = factor(RAC1P), color = factor(RAC1P))) +
  geom_density(aes(y = ..density..), alpha = 0.5) +
  geom_vline(data = median_data_race, aes(xintercept = median_log_wage, color = factor(RAC1P)), 
             linetype = "dashed", linewidth = 0.5, alpha = 0.5) +
  facet_wrap(vars(factor(Citizen))) +
  labs(title = "Distribution of log(Wages + 1) by 3 Races", subtitle = "Faceted by Citizenship Status",
       x = "log(Wages + 1) Made in Last 12 Months",
       y = "Density (Proportion)",
       fill = "Race",
       color = "Race") +
  theme_minimal()+
  theme(axis.text.x = element_text(angle = 45, hjust = 1))
```


```{r}
grid.arrange(a, wagecit, wagerace, wagerace2, nrow = 2, ncol = 2)
```

```{r}
grid.arrange(loga, logwagecit, logwagerace,logwagerace2, nrow = 2, ncol = 2)
```
## correlation matrix 1

```{r}
# Step 1: List of independent variables (excluding ST)
independent_vars <- c("RAC1P", "AGEP", "SEX", "Citizen", "ENG", 
                      "DIS", "wb50birth", "Unemployed", 
                      "High_School_Grad", "Bachelors_Degree", 
                      "HISP_dummy", "PAP", "HINS4", "MAR", "immigrant")

# One-hot encode selected categorical variables
processed_data_transformed <- processed_data2 %>%
  mutate(across(c("RAC1P", "ENG", "MAR"), as.factor))%>%dplyr::select(all_of(independent_vars))
```

```{r}

# One-hot encode selected categorical variables
processed_data_transformed<- processed_data_transformed%>%
  dummyVars(~ ., data = ., fullRank = FALSE) %>%
  predict(newdata = processed_data_transformed)
# Convert to data frame
processed_data_transformed <- as.data.frame(processed_data_transformed)
```

```{r}
# Step 3: Calculate the correlation matrix
cor_matrix <- cor(processed_data_transformed, use = "complete.obs")
```

```{r}
# Plot the correlation matrix with colors
corrplot(cor_matrix, method = "color",
         addCoef.col = 'black', tl.cex = 0.45,
         number.cex = 0.4)
```


# Multiple Regression Models Including Unemployed Individuals:

## Predicting Wages in America: 

### model (1) 
```{r}
mini_model = lm(WAGP ~ as.factor(RAC1P) + AGEP +  SEX*Citizen + as.factor(ENG) + SEX*DIS + Unemployed  + wb50birth + as.factor(ST) + High_School_Grad  + Bachelors_Degree + HISP_dummy + PAP + HINS4 + as.factor(MAR), data = processed_data2)
```

```{r}
# Get the summary of the model
summary_model <- summary(mini_model)

# Filter out rows related to state coefficients
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(summary_model$coefficients))
summary_model$coefficients <- summary_model$coefficients[!state_rows, ]

# Print the refined summary
# Extract R-squared and adjusted R-squared values
r_squared <- summary_model$r.squared
r_squared_adjusted <- summary_model$adj.r.squared

# Print the values with labels
cat("R-squared:", r_squared, "\n")
cat("Adjusted R-squared:", r_squared_adjusted, "\n")
```
### model (1) summary

```{r}
# Function to compute EHW robust standard errors
compute_ehw_se <- function(model) {
  robust_se <- sqrt(diag(vcovHC(model, type = "HC1")))
  return(robust_se)
}

# Compute EHW robust standard errors
ehw_se <- compute_ehw_se(mini_model)

# Original coefficients, t-values, p-values, and confidence intervals
orig_summary <- summary(mini_model)
orig_coefficients <- coef(mini_model)
orig_t_values <- coef(orig_summary)[, "t value"]
orig_p_values <- coef(orig_summary)[, "Pr(>|t|)"]
orig_conf_intervals <- confint(mini_model)

# Calculate t-values using EHW standard errors
t_values_ehw <- orig_coefficients / ehw_se

# Calculate p-values using EHW standard errors
p_values_ehw <- 2 * pt(abs(t_values_ehw), df = mini_model$df.residual, lower.tail = FALSE)

# Calculate confidence bounds using EHW standard errors
conf_level <- 0.95 # 95% confidence level
crit_value <- qt(1 - (1 - conf_level) / 2, df = mini_model$df.residual)
conf_bounds_ehw <- cbind(orig_coefficients - crit_value * ehw_se,
                         orig_coefficients + crit_value * ehw_se)

# Create a logical vector to filter out coefficients related to "ST"
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(orig_summary$coefficients))
filter_vector <- !state_rows

# Filter out coefficients, t-values, p-values, and confidence bounds for "ST"
orig_coefficients <- orig_coefficients[filter_vector]
orig_t_values <- orig_t_values[filter_vector]
orig_p_values <- orig_p_values[filter_vector]
orig_conf_intervals <- orig_conf_intervals[filter_vector, ]
t_values_ehw <- t_values_ehw[filter_vector]
p_values_ehw <- p_values_ehw[filter_vector]
ehw_se <- ehw_se[filter_vector]
conf_bounds_ehw <- conf_bounds_ehw[filter_vector, ]

stars <- ifelse(orig_p_values < 0.001, "***",
                ifelse(orig_p_values < 0.01, "**",
                       ifelse(orig_p_values < 0.05, "*",
                              ifelse(orig_p_values < 0.1, ".", ""))))

# Compute stars for significance based on EHW p-values
stars_ehw <- ifelse(p_values_ehw < 0.001, "***",
                    ifelse(p_values_ehw < 0.01, "**",
                           ifelse(p_values_ehw < 0.05, "*",
                                  ifelse(p_values_ehw < 0.1, ".", ""))))
```

```{r}
results <- data.frame(orig_coefficients, orig_t_values, orig_p_values, stars,
                      ehw_se, t_values_ehw, p_values_ehw, stars_ehw, conf_bounds_ehw)
rownames(results) <- names(orig_coefficients)

# Display results
#print(results)
```
```{r, results='asis'}
model1_results = kable(results, format = "latex", booktabs = TRUE)%>%
  kable_styling(latex_options = "scale_down")
print(model1_results)
```


### coef plot
```{r}
# Prepare data for plotting
plot_data <- data.frame(
    Feature = rownames(results),
    Coefficient = results$orig_coefficients,
    SE = results$ehw_se,
    Significance = results$stars
)
plot_data <- plot_data[order(plot_data$Coefficient), ]
plot_data$Feature <- factor(plot_data$Feature, levels = plot_data$Feature)
```

```{r}

# Plot using ggplot
ggplot(plot_data, aes(x = Feature, y = Coefficient)) +
    geom_point(aes(color = Significance), alpha = 0.5) +
    geom_errorbar(aes(ymin = Coefficient - SE, ymax = Coefficient + SE, color = Significance), width = 0.6)  +
    coord_flip() +
    labs(title = "Coefficient Plot with EHW Robust Standard Errors",
         subtitle = "Model (1): all respondents",
         x = "Feature",
         y = "Coefficient") +
    theme_minimal() + theme(axis.text.y = element_text(size = 8))
```

### resid plot

```{r}
# produce residual vs. fitted plot 
plot(fitted(mini_model), resid(mini_model), main = "Residual Plot: Model (1)", xlab = "Fitted Values", ylab = "Residual Values") 
  
# add a horizontal line at 0  
abline(0,0) 
```

### qqplot
```{r}
mini_model_plotting = lm(log(WAGP+1) ~ as.factor(RAC1P) + AGEP +  SEX*Citizen + as.factor(ENG) + SEX*DIS + Unemployed  + wb50birth + as.factor(ST) + High_School_Grad  + Bachelors_Degree + HISP_dummy + PAP + HINS4 + as.factor(MAR), data = processed_data2)
```
```{r}
qqnorm(resid(mini_model_plotting), main = "QQ-plot of residuals")
qqline(resid(mini_model_plotting))
mtext("Model (1) with Log-transformed Wage", side = 3, line = 0.5, cex = 0.8)

```
### box plots 1 and 2
```{r}
# Plot
boxplot1<- ggplot(processed_data2%>%filter(RAC1P %in% c(1,2,6)), aes(x = factor(RAC1P),
                                                    y = WAGP,
                                                    color = factor(RAC1P))) +
  geom_boxplot() +labs(x = "Racial Group", y = "Wages in the last 12 Months", title = "Boxplot of Wages by Race", color= "Race") + theme_minimal()
boxplot2 <-  ggplot(processed_data2%>%
                      filter(RAC1P %in% c(1,2,6)),
                    aes(x = factor(RAC1P),
                        y = log(WAGP + 1),
                        color = factor(RAC1P))) +
  geom_boxplot() +labs(x = "Racial Group", y = "log(Wage + 1) in the last 12 Months", title = "Boxplot of log(Wage + 1) by Race", color= "Race") + theme_minimal()  
grid.arrange(boxplot1, boxplot2, ncol = 2)
```

## Predicting Immigrants Wages: Differences across Wages for immigrants of different Races

### model (3)
```{r}
mini_model = lm(WAGP ~ as.factor(RAC1P) + AGEP +  SEX*Citizen + as.factor(ENG) + SEX*DIS + Unemployed + as.factor(ST) + wb50birth + High_School_Grad  + Bachelors_Degree + HISP_dummy + PAP + HINS4 + as.factor(MAR) + Years_in_US, data = immigrants_only2)
```

```{r}
# Get the summary of the model
summary_model <- summary(mini_model)

# Filter out rows related to state coefficients
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(summary_model$coefficients))
summary_model$coefficients <- summary_model$coefficients[!state_rows, ]

# Print the refined summary
# Extract R-squared and adjusted R-squared values
r_squared <- summary_model$r.squared
r_squared_adjusted <- summary_model$adj.r.squared

# Print the values with labels
cat("R-squared:", r_squared, "\n")
cat("Adjusted R-squared:", r_squared_adjusted, "\n")
```

### model (3) summary
```{r}

# Compute EHW robust standard errors
ehw_se <- compute_ehw_se(mini_model)

# Original coefficients, t-values, p-values, and confidence intervals
orig_summary <- summary(mini_model)
orig_coefficients <- coef(mini_model)
orig_t_values <- coef(orig_summary)[, "t value"]
orig_p_values <- coef(orig_summary)[, "Pr(>|t|)"]
orig_conf_intervals <- confint(mini_model)

# Calculate t-values using EHW standard errors
t_values_ehw <- orig_coefficients / ehw_se

# Calculate p-values using EHW standard errors
p_values_ehw <- 2 * pt(abs(t_values_ehw), df = mini_model$df.residual, lower.tail = FALSE)

# Calculate confidence bounds using EHW standard errors
conf_level <- 0.95 # 95% confidence level
crit_value <- qt(1 - (1 - conf_level) / 2, df = mini_model$df.residual)
conf_bounds_ehw <- cbind(orig_coefficients - crit_value * ehw_se,
                         orig_coefficients + crit_value * ehw_se)

# Create a logical vector to filter out coefficients related to "ST"
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(orig_summary$coefficients))
filter_vector <- !state_rows

# Filter out coefficients, t-values, p-values, and confidence bounds for "ST"
orig_coefficients <- orig_coefficients[filter_vector]
orig_t_values <- orig_t_values[filter_vector]
orig_p_values <- orig_p_values[filter_vector]
orig_conf_intervals <- orig_conf_intervals[filter_vector, ]
t_values_ehw <- t_values_ehw[filter_vector]
p_values_ehw <- p_values_ehw[filter_vector]
ehw_se <- ehw_se[filter_vector]
conf_bounds_ehw <- conf_bounds_ehw[filter_vector, ]

stars <- ifelse(orig_p_values < 0.001, "***",
                ifelse(orig_p_values < 0.01, "**",
                       ifelse(orig_p_values < 0.05, "*",
                              ifelse(orig_p_values < 0.1, ".", ""))))

# Compute stars for significance based on EHW p-values
stars_ehw <- ifelse(p_values_ehw < 0.001, "***",
                    ifelse(p_values_ehw < 0.01, "**",
                           ifelse(p_values_ehw < 0.05, "*",
                                  ifelse(p_values_ehw < 0.1, ".", ""))))
```

```{r}
results <- data.frame(orig_coefficients, orig_t_values, orig_p_values, stars,
                      ehw_se, t_values_ehw, p_values_ehw, stars_ehw, conf_bounds_ehw)
rownames(results) <- names(orig_coefficients)

# Display results
#print(results)
```
```{r, results='asis'}
model3_results = kable(results, format = "latex", booktabs = TRUE)%>%
  kable_styling(latex_options = "scale_down")
print(model3_results)
```
### coef plot
```{r}
# Prepare data for plotting
plot_data <- data.frame(
    Feature = rownames(results),
    Coefficient = results$orig_coefficients,
    SE = results$ehw_se,
    Significance = results$stars
)
plot_data <- plot_data[order(plot_data$Coefficient), ]
plot_data$Feature <- factor(plot_data$Feature, levels = plot_data$Feature)
```

```{r}

# Plot using ggplot
ggplot(plot_data, aes(x = Feature, y = Coefficient)) +
    geom_point(aes(color = Significance), alpha = 0.5) +
    geom_errorbar(aes(ymin = Coefficient - SE, ymax = Coefficient + SE, color = Significance), width = 0.6)  +
    coord_flip() +
    labs(title = "Coefficient Plot with EHW Robust Standard Errors",
         subtitle = "Model (3): all Immigrants",
         x = "Feature",
         y = "Coefficient") +
    theme_minimal() + theme(axis.text.y = element_text(size = 8))
```

## Predicting non-Immigrants Wages: Differences across Wages for non-immigrants of different Races

### model (2)
```{r}
mini_model = lm(WAGP ~ as.factor(RAC1P) + AGEP + as.factor(ENG) + SEX*DIS + Unemployed + as.factor(ST) + wb50birth + High_School_Grad  + Bachelors_Degree + HISP_dummy + PAP + HINS4 + as.factor(MAR), data = non_immigrants)
```

```{r}
# Get the summary of the model
summary_model <- summary(mini_model)

# Filter out rows related to state coefficients
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(summary_model$coefficients))
summary_model$coefficients <- summary_model$coefficients[!state_rows, ]

# Print the refined summary
# Extract R-squared and adjusted R-squared values
r_squared <- summary_model$r.squared
r_squared_adjusted <- summary_model$adj.r.squared

# Print the values with labels
cat("R-squared:", r_squared, "\n")
cat("Adjusted R-squared:", r_squared_adjusted, "\n")
```

### model (2) summary
```{r}

# Compute EHW robust standard errors
ehw_se <- compute_ehw_se(mini_model)

# Original coefficients, t-values, p-values, and confidence intervals
orig_summary <- summary(mini_model)
orig_coefficients <- coef(mini_model)
orig_t_values <- coef(orig_summary)[, "t value"]
orig_p_values <- coef(orig_summary)[, "Pr(>|t|)"]
orig_conf_intervals <- confint(mini_model)

# Calculate t-values using EHW standard errors
t_values_ehw <- orig_coefficients / ehw_se

# Calculate p-values using EHW standard errors
p_values_ehw <- 2 * pt(abs(t_values_ehw), df = mini_model$df.residual, lower.tail = FALSE)

# Calculate confidence bounds using EHW standard errors
conf_level <- 0.95 # 95% confidence level
crit_value <- qt(1 - (1 - conf_level) / 2, df = mini_model$df.residual)
conf_bounds_ehw <- cbind(orig_coefficients - crit_value * ehw_se,
                         orig_coefficients + crit_value * ehw_se)
```

```{r}

# Create a logical vector to filter out coefficients related to "ST"
state_rows <- grepl("^as\\.factor\\(ST\\)\\d+", rownames(orig_summary$coefficients))
filter_vector <- !state_rows

# Filter out coefficients, t-values, p-values, and confidence bounds for "ST"
orig_coefficients <- orig_coefficients[filter_vector]
orig_t_values <- orig_t_values[filter_vector]
orig_p_values <- orig_p_values[filter_vector]
orig_conf_intervals <- orig_conf_intervals[filter_vector, ]
```
```{r}
t_values_ehw <- t_values_ehw[filter_vector]
p_values_ehw <- p_values_ehw[filter_vector]
ehw_se <- ehw_se[filter_vector]
conf_bounds_ehw <- conf_bounds_ehw[filter_vector, ]

stars <- ifelse(orig_p_values < 0.001, "***",
                ifelse(orig_p_values < 0.01, "**",
                       ifelse(orig_p_values < 0.05, "*",
                              ifelse(orig_p_values < 0.1, ".", ""))))

# Compute stars for significance based on EHW p-values
stars_ehw <- ifelse(p_values_ehw < 0.001, "***",
                    ifelse(p_values_ehw < 0.01, "**",
                           ifelse(p_values_ehw < 0.05, "*",
                                  ifelse(p_values_ehw < 0.1, ".", ""))))
```
```{r}
results <- data.frame(orig_coefficients, orig_t_values, orig_p_values, stars,
                      ehw_se, t_values_ehw, p_values_ehw, stars_ehw, conf_bounds_ehw)
rownames(results) <- names(orig_coefficients)

# Display results
#print(results)
```

```{r, results='asis'}
model2_results = kable(results, format = "latex", booktabs = TRUE)%>%
  kable_styling(latex_options = "scale_down")
print(model2_results)
```


### coef plot 

```{r}
# Prepare data for plotting
plot_data <- data.frame(
    Feature = rownames(results),
    Coefficient = results$orig_coefficients,
    SE = results$ehw_se,
    Significance = results$stars
)
plot_data <- plot_data[order(plot_data$Coefficient), ]
plot_data$Feature <- factor(plot_data$Feature, levels = plot_data$Feature)
```

```{r}

# Plot using ggplot
ggplot(plot_data, aes(x = Feature, y = Coefficient)) +
    geom_point(aes(color = Significance), alpha = 0.5) +
    geom_errorbar(aes(ymin = Coefficient - SE, ymax = Coefficient + SE, color = Significance), width = 0.6)  +
    coord_flip() +
    labs(title = "Coefficient Plot with EHW Robust Standard Errors",
         subtitle = "Model (2): all non-Immigrants",
         x = "Feature",
         y = "Coefficient") +
    theme_minimal() + theme(axis.text.y = element_text(size = 8))
```

## Predicting Wages for Asian: Differences across Wages for Asian immigrants and from top 5 countries and also non-immigrants

### selecting new data for asians
```{r}
asian_only = processed_data2%>%filter(RAC1P==6)
asian_only_im = immigrants_only2%>%filter(RAC1P==6)
```
```{r}
largest_subgroup = asian_only_im%>%group_by(POBP)%>%
  summarise(count = n())%>%
  mutate(per = (count/sum(count))*100)%>%
  arrange(desc(per))%>%head(5)%>%pull(POBP)
```

```{r}
asian_only_im = asian_only_im%>%filter(POBP %in% largest_subgroup)
```

### plots for asians

```{r}
median_rac1p_immigrants <- immigrants_only2 %>% 
    filter(RAC1P %in% c(1, 2, 6)) %>%
    group_by(RAC1P) %>%
    summarize(median_wage = median(log(WAGP + 1), na.rm = TRUE))

median_rac1p_nonimmigrants <- processed_data2 %>% 
    filter(RAC1P %in% c(1, 2, 6), immigrant == 0) %>%
    group_by(RAC1P) %>%
    summarize(median_wage = median(log(WAGP + 1), na.rm = TRUE))

median_asian_immigrants <- asian_only_im %>%
    group_by(POBP) %>%
    summarize(median_wage = median(log(WAGP + 1), na.rm = TRUE))

median_asian_nonimmigrants <- asian_only %>%filter(immigrant == 0)%>%
    summarize(median_wage = median(log(WAGP + 1), na.rm = TRUE))

median_asian_immigrants2 <- asian_only %>%filter(immigrant == 1)%>%
    summarize(median_wage = median(log(WAGP + 1), na.rm = TRUE))
```


```{r}
# Create density plot for RAC1P groups
density_plot_rac1p <- ggplot(immigrants_only2 %>% filter(RAC1P %in% c(1, 2, 6)), aes(x = log(WAGP + 1), fill = factor(RAC1P), color = factor(RAC1P))) +
  geom_density(aes(y = ..density..), alpha = 0.5) +
  labs(title = "Immigrant log(Wages + 1) by Race",
       x = "log(Wages + 1)",
       y = "Density (Proportion)") + ylim(0,0.6)+
    geom_vline(data = median_rac1p_immigrants, aes(xintercept = median_wage, color = factor(RAC1P)), linetype = "dashed")

# Create density plot for RAC1P groups
density_plot_rac1p2 <- ggplot(processed_data2 %>% filter(RAC1P %in% c(1, 2, 6) & immigrant ==0), aes(x = log(WAGP + 1), fill = factor(RAC1P), color = factor(RAC1P))) +
  geom_density(aes(y = ..density..), alpha = 0.5) +
  labs(title = "non-Immigrant log(Wages + 1) by Race",
       x = "log(Wages + 1)",
       y = "Density (Proportion)") + ylim(0,0.6)+geom_vline(data = median_rac1p_nonimmigrants, aes(xintercept = median_wage, color = factor(RAC1P)), linetype = "dashed")

#Create density plot for Asian immigrants

density_plot_asian <- ggplot(asian_only_im, aes(x = log(WAGP + 1), fill = factor(POBP), color = factor(POBP))) +
  geom_density(aes(y = ..density..), alpha = 0.5) +
  labs(title = "Immigrant log(Wages + 1) for Asians by Place of Birth",
       x = "log(Wages + 1)",
       y = "Density (Proportion)")+ ylim(0,0.6)+geom_vline(data = median_asian_immigrants, aes(xintercept = median_wage, color = factor(POBP)), linetype = "dashed")

density_plot_asian2 <- ggplot(asian_only%>%filter(immigrant == 0), aes(x = log(WAGP + 1))) +
  geom_density(aes(y = ..density..), alpha = 0.5, alpha = 0.5, fill = "cornflowerblue", color = "cornflowerblue") +
  labs(title = "non-Immigrants log(Wages + 1) for Asians",
       x = "log(Wages + 1)",
       y = "Density (Proportion)")+ ylim(0,0.6)+
    geom_vline(data = median_asian_nonimmigrants, aes(xintercept = median_wage), linetype = "dashed", color = "cornflowerblue")

density_plot_asian3 <- ggplot(asian_only%>%filter(immigrant == 1), aes(x = log(WAGP + 1))) +
  geom_density(aes(y = ..density..), alpha = 0.5, alpha = 0.5, fill = "cornflowerblue", color = "cornflowerblue") +
  labs(title = "Immigrant log(Wages + 1) for Asians",
       x = "log(Wages + 1)",
       y = "Density (Proportion)")+ ylim(0,0.6)+
    geom_vline(data = median_asian_immigrants2, aes(xintercept = median_wage), linetype = "dashed", color = "cornflowerblue")
# Combine plots side by side
library(gridExtra)
grid.arrange(density_plot_rac1p, density_plot_rac1p2, density_plot_asian, density_plot_asian2, density_plot_asian3, ncol = 2, nrow = 3)

```

### model (4) : model 1 for asian immigrants accounting for country of origin

```{r}
mini_model = lm(WAGP ~ AGEP +  SEX*Citizen + as.factor(ENG) + SEX*DIS + Unemployed + as.factor(ST) + wb50birth +  High_School_Grad + Bachelors_Degree + PAP + HINS4 + as.factor(MAR) + as.factor(POBP) + Years_in_US, data = asian_only_im)
```

```{r}
# Get the summary of the model
summary_model <- summary(mini_model)

# Filter out rows related to state coefficients
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(summary_model$coefficients))
summary_model$coefficients <- summary_model$coefficients[!state_rows, ]

# Print the refined summary
summary_model
```
### model (4) summary
```{r}

# Compute EHW robust standard errors
ehw_se <- compute_ehw_se(mini_model)

# Original coefficients, t-values, p-values, and confidence intervals
orig_summary <- summary(mini_model)
orig_coefficients <- coef(mini_model)
orig_t_values <- coef(orig_summary)[, "t value"]
orig_p_values <- coef(orig_summary)[, "Pr(>|t|)"]
orig_conf_intervals <- confint(mini_model)

# Calculate t-values using EHW standard errors
t_values_ehw <- orig_coefficients / ehw_se

# Calculate p-values using EHW standard errors
p_values_ehw <- 2 * pt(abs(t_values_ehw), df = mini_model$df.residual, lower.tail = FALSE)

# Calculate confidence bounds using EHW standard errors
conf_level <- 0.95 # 95% confidence level
crit_value <- qt(1 - (1 - conf_level) / 2, df = mini_model$df.residual)
conf_bounds_ehw <- cbind(orig_coefficients - crit_value * ehw_se,
                         orig_coefficients + crit_value * ehw_se)

# Create a logical vector to filter out coefficients related to "ST"
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(orig_summary$coefficients))
filter_vector <- !state_rows

# Filter out coefficients, t-values, p-values, and confidence bounds for "ST"
orig_coefficients <- orig_coefficients[filter_vector]
orig_t_values <- orig_t_values[filter_vector]
orig_p_values <- orig_p_values[filter_vector]
orig_conf_intervals <- orig_conf_intervals[filter_vector, ]
t_values_ehw <- t_values_ehw[filter_vector]
p_values_ehw <- p_values_ehw[filter_vector]
ehw_se <- ehw_se[filter_vector]
conf_bounds_ehw <- conf_bounds_ehw[filter_vector, ]

stars <- ifelse(orig_p_values < 0.001, "***",
                ifelse(orig_p_values < 0.01, "**",
                       ifelse(orig_p_values < 0.05, "*",
                              ifelse(orig_p_values < 0.1, ".", ""))))

# Compute stars for significance based on EHW p-values
stars_ehw <- ifelse(p_values_ehw < 0.001, "***",
                    ifelse(p_values_ehw < 0.01, "**",
                           ifelse(p_values_ehw < 0.05, "*",
                                  ifelse(p_values_ehw < 0.1, ".", ""))))
```

```{r}
results <- data.frame(orig_coefficients, orig_t_values, orig_p_values, stars,
                      ehw_se, t_values_ehw, p_values_ehw, stars_ehw, conf_bounds_ehw)
rownames(results) <- names(orig_coefficients)

# Display results
#print(results)
```

```{r, results='asis'}
model4_results = kable(results, format = "latex", booktabs = TRUE)%>%
  kable_styling(latex_options = "scale_down")
print(model4_results)
```
### coef plot
```{r}
# Prepare data for plotting
plot_data <- data.frame(
    Feature = rownames(results),
    Coefficient = results$orig_coefficients,
    SE = results$ehw_se,
    Significance = results$stars
)
plot_data <- plot_data[order(plot_data$Coefficient), ]
plot_data$Feature <- factor(plot_data$Feature, levels = plot_data$Feature)
```

```{r}

# Plot using ggplot
ggplot(plot_data, aes(x = Feature, y = Coefficient)) +
    geom_point(aes(color = Significance), alpha = 0.5) +
    geom_errorbar(aes(ymin = Coefficient - SE, ymax = Coefficient + SE, color = Significance), width = 0.6)  +
    coord_flip() +
    labs(title = "Coefficient Plot with EHW Robust Standard Errors",
         subtitle = "Model (4): all Asian Immigrants",
         x = "Feature",
         y = "Coefficient") +
    theme_minimal() + theme(axis.text.y = element_text(size = 8))
```
### box plots 3 and 4
```{r}
# Plot
boxplot3<- ggplot(asian_only_im, aes(x = factor(POBP),
                                                    y = WAGP,
                                                    color = factor(POBP))) +
  geom_boxplot() +labs(x = "Place of Birth", y = "Wages in the last 12 Months", title = "Boxplot of Wages by Place of Birth", color= "Place of Birth") + theme_minimal()
boxplot4 <-  ggplot(asian_only_im, aes(x = factor(POBP),
                                                    y = log(WAGP + 1),
                                                    color = factor(POBP))) +
  geom_boxplot() +labs(x = "Place of Birth", y = "log(Wage + 1) in the last 12 Months", title = "Boxplot of log(Wage + 1) by Place of Birth", color= "Place of Birth") + theme_minimal()
grid.arrange(boxplot3, boxplot4, ncol = 2)
```

### model (5) model 2 for all asians: using immigrants instead of citizen for comparison 

```{r}
model2.2 = lm(WAGP ~ AGEP + SEX*immigrant + as.factor(ENG) + SEX*DIS + Unemployed + as.factor(ST) + wb50birth + High_School_Grad + Bachelors_Degree + PAP + HINS4 + as.factor(MAR) , data = asian_only)
```

```{r}
# Get the summary of the model
summary_model <- summary(model2.2)

# Filter out rows related to state coefficients
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(summary_model$coefficients))
summary_model$coefficients <- summary_model$coefficients[!state_rows, ]

# Print the refined summary
# Extract R-squared and adjusted R-squared values
r_squared <- summary_model$r.squared
r_squared_adjusted <- summary_model$adj.r.squared

# Print the values with labels
cat("R-squared:", r_squared, "\n")
cat("Adjusted R-squared:", r_squared_adjusted, "\n")
```

### model (5) summary
```{r}

# Compute EHW robust standard errors
ehw_se <- compute_ehw_se(model2.2)

# Original coefficients, t-values, p-values, and confidence intervals
orig_summary <- summary(model2.2)
orig_coefficients <- coef(model2.2)
orig_t_values <- coef(orig_summary)[, "t value"]
orig_p_values <- coef(orig_summary)[, "Pr(>|t|)"]
orig_conf_intervals <- confint(model2.2)

# Calculate t-values using EHW standard errors
t_values_ehw <- orig_coefficients / ehw_se

# Calculate p-values using EHW standard errors
p_values_ehw <- 2 * pt(abs(t_values_ehw), df = model2.2$df.residual, lower.tail = FALSE)

# Calculate confidence bounds using EHW standard errors
conf_level <- 0.95 # 95% confidence level
crit_value <- qt(1 - (1 - conf_level) / 2, df = model2.2$df.residual)
conf_bounds_ehw <- cbind(orig_coefficients - crit_value * ehw_se,
                         orig_coefficients + crit_value * ehw_se)

# Create a logical vector to filter out coefficients related to "ST"
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(orig_summary$coefficients))
filter_vector <- !state_rows

# Filter out coefficients, t-values, p-values, and confidence bounds for "ST"
orig_coefficients <- orig_coefficients[filter_vector]
orig_t_values <- orig_t_values[filter_vector]
orig_p_values <- orig_p_values[filter_vector]
orig_conf_intervals <- orig_conf_intervals[filter_vector, ]
t_values_ehw <- t_values_ehw[filter_vector]
p_values_ehw <- p_values_ehw[filter_vector]
ehw_se <- ehw_se[filter_vector]
conf_bounds_ehw <- conf_bounds_ehw[filter_vector, ]

stars <- ifelse(orig_p_values < 0.001, "***",
                ifelse(orig_p_values < 0.01, "**",
                       ifelse(orig_p_values < 0.05, "*",
                              ifelse(orig_p_values < 0.1, ".", ""))))

# Compute stars for significance based on EHW p-values
stars_ehw <- ifelse(p_values_ehw < 0.001, "***",
                    ifelse(p_values_ehw < 0.01, "**",
                           ifelse(p_values_ehw < 0.05, "*",
                                  ifelse(p_values_ehw < 0.1, ".", ""))))
```


```{r}
results <- data.frame(orig_coefficients, orig_t_values, orig_p_values, stars,
                      ehw_se, t_values_ehw, p_values_ehw, stars_ehw, conf_bounds_ehw)
rownames(results) <- names(orig_coefficients)

# Display results
#print(results)
```

```{r, results='asis'}
model5_results = kable(results, format = "latex", booktabs = TRUE)%>%
  kable_styling(latex_options = "scale_down")
print(model5_results)
```

```{r}
# Prepare data for plotting
plot_data <- data.frame(
    Feature = rownames(results),
    Coefficient = results$orig_coefficients,
    SE = results$ehw_se,
    Significance = results$stars
)
plot_data <- plot_data[order(plot_data$Coefficient), ]
plot_data$Feature <- factor(plot_data$Feature, levels = plot_data$Feature)
```

```{r}

# Plot using ggplot
ggplot(plot_data, aes(x = Feature, y = Coefficient)) +
    geom_point(aes(color = Significance), alpha = 0.5) +
    geom_errorbar(aes(ymin = Coefficient - SE, ymax = Coefficient + SE, color = Significance), width = 0.6)  +
    coord_flip() +
    labs(title = "Coefficient Plot with EHW Robust Standard Errors",
         subtitle = "Model (5): all Asians",
         x = "Feature",
         y = "Coefficient") +
    theme_minimal() + theme(axis.text.y = element_text(size = 8))
```

## Predicting Immigrants Wages: Differences across Wages for Hispanic immigrants from top 5 countries and also non-immigrants

### HISP data cleaning
```{r}
hisp_only = processed_data2%>%filter(HISP_dummy==1)
hisp_only_im = immigrants_only2%>%filter(HISP_dummy==1)
```
```{r}
largest_subgroup = hisp_only_im%>%group_by(POBP)%>%
  summarise(count = n())%>%
  mutate(per = (count/sum(count))*100)%>%
  arrange(desc(per))%>%head(5)%>%pull(POBP)
```

```{r}
hisp_only_im = hisp_only_im%>%filter(POBP %in% largest_subgroup)
```

### HISP EDA

```{r}
# Calculate median wages for each plot

# Plot 1
median_rac1p_immigrants <- hisp_only_im %>%
    group_by(RAC1P) %>%
    summarize(median_wage = median(log(WAGP + 1), na.rm = TRUE))

# Plot 2
median_rac1p_nonimmigrants <- hisp_only %>%
    filter(immigrant == 0) %>%
    group_by(RAC1P) %>%
    summarize(median_wage = median(log(WAGP + 1), na.rm = TRUE))

# Plot 3
median_hisp_immigrants <- hisp_only_im %>%
    group_by(POBP) %>%
    summarize(median_wage = median(log(WAGP + 1), na.rm = TRUE))

# Plot 4
median_hisp_nonimmigrants <- hisp_only %>%
    filter(immigrant == 0) %>%
    summarize(median_wage = median(log(WAGP + 1), na.rm = TRUE))

# Plot 5
median_hisp_only_im <- hisp_only %>%
    filter(immigrant == 1) %>%
    summarize(median_wage = median(log(WAGP + 1), na.rm = TRUE))
```

```{r}
# Create density plot for RAC1P groups (immigrants)
density_plot_rac1p <- ggplot(hisp_only_im, aes(x = log(WAGP + 1), fill = factor(RAC1P), color = factor(RAC1P))) +
    geom_density(aes(y = ..density..), alpha = 0.5) +
    geom_vline(data = median_rac1p_immigrants, aes(xintercept = median_wage, color = factor(RAC1P)), linetype = "dashed") +
    labs(title = "Hispanic Immigrant log(Wages + 1) by Race",
         x = "log(Wages + 1)",
         y = "Density (Proportion)", 
         color = "Race", 
         fill = "Race") +
    ylim(0, 0.6)

# Create density plot for RAC1P groups (non-immigrants)
density_plot_rac1p2 <- ggplot(hisp_only %>% filter(immigrant == 0), aes(x = log(WAGP + 1), fill = factor(RAC1P), color = factor(RAC1P))) +
    geom_density(aes(y = ..density..), alpha = 0.5) +
    geom_vline(data = median_rac1p_nonimmigrants, aes(xintercept = median_wage, color = factor(RAC1P)), linetype = "dashed") +
    labs(title = "non-Immigrant Hispanic log(Wages + 1) by Race",
         x = "log(Wages + 1)",
         y = "Density (Proportion)", 
         color = "Race", 
         fill = "Race") +
    ylim(0, 0.6)

# Create density plot for Hispanic immigrants by country of origin
density_plot_hisp <- ggplot(hisp_only_im, aes(x = log(WAGP + 1), fill = factor(POBP), color = factor(POBP))) +
    geom_density(aes(y = ..density..), alpha = 0.5) +
    geom_vline(data = median_hisp_immigrants, aes(xintercept = median_wage, color = factor(POBP)), linetype = "dashed") +
    labs(title = "log(Wages + 1) for Hispanics by Place of Birth",
         x = "log(Wages + 1)",
         y = "Density (Proportion)", 
         color = "Place of Birth", 
         fill = "Place of Birth") +
    ylim(0, 0.6)

# Create density plot for Hispanic non-immigrants
density_plot_hisp2 <- ggplot(hisp_only %>% filter(immigrant == 0), aes(x = log(WAGP + 1))) +
    geom_density(aes(y = ..density..), alpha = 0.5, fill = "cornflowerblue", color = "cornflowerblue") +
    geom_vline(data = median_hisp_nonimmigrants, aes(xintercept = median_wage), linetype = "dashed", color = "cornflowerblue") +
    labs(title = "non-Immigrant log(Wages + 1) for Hispanics",
         x = "log(Wages + 1)",
         y = "Density (Proportion)") +
    ylim(0, 0.6)

# Create density plot for Hispanic immigrants
density_plot_hisp3 <- ggplot(hisp_only %>% filter(immigrant == 1), aes(x = log(WAGP + 1))) +
    geom_density(aes(y = ..density..), alpha = 0.5, fill = "cornflowerblue", color = "cornflowerblue") +
    geom_vline(data = median_hisp_only_im, aes(xintercept = median_wage), linetype = "dashed", color = "cornflowerblue") +
    labs(title = "Immigrant log(Wages + 1) for Hispanics",
         x = "log(Wages + 1)",
         y = "Density (Proportion)") +
    ylim(0, 0.6)

# Combine plots side by side
grid.arrange(density_plot_rac1p, density_plot_rac1p2, density_plot_hisp, density_plot_hisp2, density_plot_hisp3, ncol = 2, nrow = 3)
```


### Model (6) HISP model 1 for immigrants by POBP

```{r}
mini_model = lm(WAGP ~  as.factor(RAC1P) + AGEP + SEX*Citizen + as.factor(ENG) + SEX*DIS + Unemployed + as.factor(ST) + High_School_Grad + Bachelors_Degree + PAP + HINS4 + as.factor(MAR) + as.factor(POBP) + Years_in_US, data = hisp_only_im)
```

```{r}
# Get the summary of the model
summary_model <- summary(mini_model)

# Filter out rows related to state coefficients
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(summary_model$coefficients))
summary_model$coefficients <- summary_model$coefficients[!state_rows, ]

# Print the refined summary
# Extract R-squared and adjusted R-squared values
r_squared <- summary_model$r.squared
r_squared_adjusted <- summary_model$adj.r.squared

# Print the values with labels
cat("R-squared:", r_squared, "\n")
cat("Adjusted R-squared:", r_squared_adjusted, "\n")
```


### model (6) summary

```{r}

# Compute EHW robust standard errors
ehw_se <- compute_ehw_se(mini_model)

# Original coefficients, t-values, p-values, and confidence intervals
orig_summary <- summary(mini_model)
orig_coefficients <- coef(mini_model)
orig_t_values <- coef(orig_summary)[, "t value"]
orig_p_values <- coef(orig_summary)[, "Pr(>|t|)"]
orig_conf_intervals <- confint(mini_model)

# Calculate t-values using EHW standard errors
t_values_ehw <- orig_coefficients / ehw_se

# Calculate p-values using EHW standard errors
p_values_ehw <- 2 * pt(abs(t_values_ehw), df = mini_model$df.residual, lower.tail = FALSE)

# Calculate confidence bounds using EHW standard errors
conf_level <- 0.95 # 95% confidence level
crit_value <- qt(1 - (1 - conf_level) / 2, df = mini_model$df.residual)
conf_bounds_ehw <- cbind(orig_coefficients - crit_value * ehw_se,
                         orig_coefficients + crit_value * ehw_se)

# Create a logical vector to filter out coefficients related to "ST"
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(orig_summary$coefficients))
filter_vector <- !state_rows

# Filter out coefficients, t-values, p-values, and confidence bounds for "ST"
orig_coefficients <- orig_coefficients[filter_vector]
orig_t_values <- orig_t_values[filter_vector]
orig_p_values <- orig_p_values[filter_vector]
orig_conf_intervals <- orig_conf_intervals[filter_vector, ]
t_values_ehw <- t_values_ehw[filter_vector]
p_values_ehw <- p_values_ehw[filter_vector]
ehw_se <- ehw_se[filter_vector]
conf_bounds_ehw <- conf_bounds_ehw[filter_vector, ]

stars <- ifelse(orig_p_values < 0.001, "***",
                ifelse(orig_p_values < 0.01, "**",
                       ifelse(orig_p_values < 0.05, "*",
                              ifelse(orig_p_values < 0.1, ".", ""))))

# Compute stars for significance based on EHW p-values
stars_ehw <- ifelse(p_values_ehw < 0.001, "***",
                    ifelse(p_values_ehw < 0.01, "**",
                           ifelse(p_values_ehw < 0.05, "*",
                                  ifelse(p_values_ehw < 0.1, ".", ""))))
```


```{r}
results <- data.frame(orig_coefficients, orig_t_values, orig_p_values, stars,
                      ehw_se, t_values_ehw, p_values_ehw, stars_ehw, conf_bounds_ehw)
rownames(results) <- names(orig_coefficients)

# Display results
#print(results)
```

```{r, results='asis'}
model6_results = kable(results, format = "latex", booktabs = TRUE)%>%
  kable_styling(latex_options = "scale_down")
print(model6_results)
```
### coef plot 

```{r}
# Prepare data for plotting
plot_data <- data.frame(
    Feature = rownames(results),
    Coefficient = results$orig_coefficients,
    SE = results$ehw_se,
    Significance = results$stars
)
plot_data <- plot_data[order(plot_data$Coefficient), ]
plot_data$Feature <- factor(plot_data$Feature, levels = plot_data$Feature)
```

```{r}

# Plot using ggplot
ggplot(plot_data, aes(x = Feature, y = Coefficient)) +
    geom_point(aes(color = Significance), alpha = 0.5) +
    geom_errorbar(aes(ymin = Coefficient - SE, ymax = Coefficient + SE, color = Significance), width = 0.6)  +
    coord_flip() +
    labs(title = "Coefficient Plot with EHW Robust Standard Errors",
         subtitle = "Model (6): all Hispanic Immigrants",
         x = "Feature",
         y = "Coefficient") +
    theme_minimal() + theme(axis.text.y = element_text(size = 8))
```
### box plots 5 and 6
```{r}

# Plot
boxplot5<- ggplot(hisp_only_im, aes(x = factor(POBP),
                                                    y = WAGP,
                                                    color = factor(POBP))) +
  geom_boxplot() +labs(x = "Place of Birth", y = "Wages in the last 12 Months", title = "Boxplot of Wages by Place of Birth", color= "Place of Birth"
) + theme_minimal()
boxplot6 <-  ggplot(hisp_only_im, aes(x = factor(POBP),
                                                    y = log(WAGP + 1),
                                                    color = factor(POBP))) +
  geom_boxplot() +labs(x = "Place of Birth", y = "log(Wage + 1) in the last 12 Months", title = "Boxplot of log(Wage + 1) by Place of Birth", color= "Place of Birth"
) + theme_minimal()
grid.arrange(boxplot5, boxplot6, ncol = 2)
```


### model (7) HISP model 2 for all hispanics using immigrant for comparison

```{r}
model2.2 = lm(WAGP ~ as.factor(RAC1P) + AGEP + SEX*immigrant + as.factor(ENG) + SEX*DIS + Unemployed + wb50birth+ as.factor(ST) + High_School_Grad + Bachelors_Degree + PAP + HINS4 + as.factor(MAR), data = hisp_only)
```

```{r}
# Get the summary of the model
summary_model <- summary(model2.2)

# Filter out rows related to state coefficients
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(summary_model$coefficients))
summary_model$coefficients <- summary_model$coefficients[!state_rows, ]

# Print the refined summary
# Extract R-squared and adjusted R-squared values
r_squared <- summary_model$r.squared
r_squared_adjusted <- summary_model$adj.r.squared

# Print the values with labels
cat("R-squared:", r_squared, "\n")
cat("Adjusted R-squared:", r_squared_adjusted, "\n")
```


### model (7) summary
```{r}

# Compute EHW robust standard errors
ehw_se <- compute_ehw_se(model2.2)

# Original coefficients, t-values, p-values, and confidence intervals
orig_summary <- summary(model2.2)
orig_coefficients <- coef(model2.2)
orig_t_values <- coef(orig_summary)[, "t value"]
orig_p_values <- coef(orig_summary)[, "Pr(>|t|)"]
orig_conf_intervals <- confint(model2.2)

# Calculate t-values using EHW standard errors
t_values_ehw <- orig_coefficients / ehw_se

# Calculate p-values using EHW standard errors
p_values_ehw <- 2 * pt(abs(t_values_ehw), df = model2.2$df.residual, lower.tail = FALSE)

# Calculate confidence bounds using EHW standard errors
conf_level <- 0.95 # 95% confidence level
crit_value <- qt(1 - (1 - conf_level) / 2, df = model2.2$df.residual)
conf_bounds_ehw <- cbind(orig_coefficients - crit_value * ehw_se,
                         orig_coefficients + crit_value * ehw_se)

# Create a logical vector to filter out coefficients related to "ST"
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(orig_summary$coefficients))
filter_vector <- !state_rows

# Filter out coefficients, t-values, p-values, and confidence bounds for "ST"
orig_coefficients <- orig_coefficients[filter_vector]
orig_t_values <- orig_t_values[filter_vector]
orig_p_values <- orig_p_values[filter_vector]
orig_conf_intervals <- orig_conf_intervals[filter_vector, ]
t_values_ehw <- t_values_ehw[filter_vector]
p_values_ehw <- p_values_ehw[filter_vector]
ehw_se <- ehw_se[filter_vector]
conf_bounds_ehw <- conf_bounds_ehw[filter_vector, ]

stars <- ifelse(orig_p_values < 0.001, "***",
                ifelse(orig_p_values < 0.01, "**",
                       ifelse(orig_p_values < 0.05, "*",
                              ifelse(orig_p_values < 0.1, ".", ""))))

# Compute stars for significance based on EHW p-values
stars_ehw <- ifelse(p_values_ehw < 0.001, "***",
                    ifelse(p_values_ehw < 0.01, "**",
                           ifelse(p_values_ehw < 0.05, "*",
                                  ifelse(p_values_ehw < 0.1, ".", ""))))
```


```{r}
results <- data.frame(orig_coefficients, orig_t_values, orig_p_values, stars,
                      ehw_se, t_values_ehw, p_values_ehw, stars_ehw, conf_bounds_ehw)
rownames(results) <- names(orig_coefficients)

# Display results
#print(results)
```

```{r, results='asis'}
model7_results = kable(results, format = "latex", booktabs = TRUE)%>%
  kable_styling(latex_options = "scale_down")
print(model7_results)
```

### coef plot

```{r}
# Prepare data for plotting
plot_data <- data.frame(
    Feature = rownames(results),
    Coefficient = results$orig_coefficients,
    SE = results$ehw_se,
    Significance = results$stars
)
plot_data <- plot_data[order(plot_data$Coefficient), ]
plot_data$Feature <- factor(plot_data$Feature, levels = plot_data$Feature)
```

```{r}

# Plot using ggplot
ggplot(plot_data, aes(x = Feature, y = Coefficient)) +
    geom_point(aes(color = Significance), alpha = 0.5) +
    geom_errorbar(aes(ymin = Coefficient - SE, ymax = Coefficient + SE, color = Significance), width = 0.6)  +
    coord_flip() +
    labs(title = "Coefficient Plot with EHW Robust Standard Errors",
         subtitle = "Model (7): all Hispanics",
         x = "Feature",
         y = "Coefficient") +
    theme_minimal() + theme(axis.text.y = element_text(size = 8))
```




