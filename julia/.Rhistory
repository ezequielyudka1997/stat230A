black_dummy = (RAC1P == 2))
immigrants_only = processed_data2%>%filter(CIT%in% c(4,5))
immigrants_only2 = immigrants_only%>%filter(RAC1P%in%c(1,2,6,8,9))
non_immigrants = processed_data2%>%filter(immigrant==1, RAC1P%in%c(1,2,6,8,9))
install.packages("pbsapply")
install.packages("pbapply")
library(pbapply)
# Function to compute bootstrap standard errors, confidence intervals, and p-values
compute_bootstrap_results <- function(model_formula, data, B = 50, conf_level = 0.95,
verbose = TRUE) {
# Function to fit the model and extract coefficients
boot_fn <- function(data, indices) {
boot_sample <- data[indices, ]
fit <- lm(model_formula, data = boot_sample)
return(coef(fit))
}
# Perform bootstrap
#results <- boot(data, boot_fn, R = B)
# Number of cores to use
#num_cores <- parallel::detectCores() - 1
#cl <- parallel::makeCluster(num_cores, type = ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK"))
# Perform bootstrap
#results <- boot(data, boot_fn, R = B, parallel = "snow", ncpus = num_cores, cl = cl)
#parallel::stopCluster(cl)
# Perform bootstrap
# Setup parallelization based on the system
num_cores <- parallel::detectCores() - 1
parallel_type <- ifelse(.Platform$OS.type == "windows", "snow", "multicore")
if (verbose) {
# Perform bootstrap with progress bar
results <- pbsapply(1:B, function(i) {
boot(data, boot_fn, R = 1, parallel = parallel_type, ncpus = num_cores)
}, cl = num_cores)
results <- do.call(rbind, lapply(results, function(x) x$t))
results <- list(t = results)
} else {
# Perform bootstrap without progress bar
results <- boot(data, boot_fn, R = B, parallel = parallel_type, ncpus = num_cores)
}
# Calculate means and standard errors
boot_means <- colMeans(results$t)
boot_se <- apply(results$t, 2, function(x) sqrt(mean((x - boot_means)^2)))
# Compute standard errors
#boot_se <- apply(results$t, 2, function(x) sqrt(mean((x - mean(x))^2)))
# Compute confidence intervals
conf_bounds <- apply(results$t, 2, function(x) quantile(x, c((1 - conf_level) / 2, 1 - (1 - conf_level) / 2)))
# Get original coefficients
original_coefs <- coef(lm(model_formula, data = data))
p_values <- sapply(1:ncol(results$t), function(i) {
mean(abs(results$t[, i]) > abs(original_coefs[i]))
})
# Compute stars for significance
stars <- ifelse(p_values < 0.001, "***",
ifelse(p_values < 0.01, "**",
ifelse(p_values < 0.05, "*",
ifelse(p_values < 0.1, ".", ""))))
return(list(boot_se = boot_se,
conf_bounds = conf_bounds,
p_values = p_values,
stars = stars))
}
# Original model formula
model_formula <- WAGP ~ as.factor(RAC1P) + AGEP +  SEX*Citizen + as.factor(ENG) + SEX*DIS + Unemployed + as.factor(ST) + High_School_Grad  + Bachelors_Degree + HISP_dummy + PAP + HINS4 + as.factor(MAR)
# Apply the function to the mini_model
results <- compute_bootstrap_results(model_formula, processed_data2)
# Original model formula
model_formula <- WAGP ~ as.factor(RAC1P) + AGEP +  SEX*Citizen + as.factor(ENG) + SEX*DIS + Unemployed + as.factor(ST) + High_School_Grad  + Bachelors_Degree + HISP_dummy + PAP + HINS4 + as.factor(MAR)
# Apply the function to the mini_model
results <- compute_bootstrap_results(model_formula, processed_data2)
library(tidyverse)
library(gridExtra)
library(MASS)
library(corrplot)
library(sandwich)
library(caret)
zip_file_path <- "../processed_data.zip"
csv_file_inside_zip <- "processed_data.csv"
processed_data <- read.csv(unz(zip_file_path, csv_file_inside_zip), header = TRUE,
sep = ",")
processed_data <- processed_data %>%
mutate(
DIS = ifelse(DIS == 2, 0, 1),
HINS4 = 1 - as.numeric(HINS4),
High_School_Grad = ifelse(SCHL >= 16, 1, 0))
processed_data$ENG[is.na(processed_data$ENG)] <- 0
#colnames(processed_data)
processed_data$Years_naturalized[processed_data$Foreign_born == 0] <- 0
processed_data$Years_in_US[processed_data$Foreign_born == 0] <- 0
processed_data$Years_naturalized[processed_data$CIT == 5] <- 0
processed_data = processed_data%>%filter(CIT != 2)
processed_data$wb50birth <- processed_data$FER
processed_data$wb50birth[is.na(processed_data$FER) &
(processed_data$AGEP >= 50 | processed_data$SEX == 0)] <- 0
#colSums(is.na(processed_data))
processed_data2 = processed_data%>%filter(!(WAGP == 0 & Unemployed == 0))
processed_data2 = processed_data2%>%mutate(immigrant = as.integer(CIT%in%c(4,5)))
processed_data2 <- processed_data2%>%mutate(white_dummy = (RAC1P == 1),
asian_dummy = (RAC1P == 6),
black_dummy = (RAC1P == 2))
immigrants_only = processed_data2%>%filter(CIT%in% c(4,5))
immigrants_only2 = immigrants_only%>%filter(RAC1P%in%c(1,2,6,8,9))
non_immigrants = processed_data2%>%filter(immigrant==0, RAC1P%in%c(1,2,6,8,9))
a <- ggplot(processed_data2,aes(x = WAGP, y = ..density..)) + geom_density(color = 'cyan3', fill = 'cyan3', alpha = 0.5) +
labs(titles = "Distribution of Wages", x = "Wages Made in Last 12 Months")+ geom_vline(aes(xintercept=median(WAGP)),
color="cyan3", linetype="dashed", linewidth=0.5, alpha = 0.5)
# Calculate median wage for each citizenship group
median_data <- processed_data2 %>%
group_by(Citizen) %>%
summarise(median_wage = median(WAGP))
# Plot
wagecit <- ggplot(processed_data2, aes(x = WAGP, fill = factor(Citizen), color = factor(Citizen))) +
geom_density(alpha = 0.5) +
geom_vline(data = median_data, aes(xintercept = median_wage, color = factor(Citizen)),
linetype = "dashed", linewidth = 0.8, alpha = 0.8) +
labs(title = "Distribution of Wages by Citizenship Status",
x = "Wages Made in Last 12 Months",
y = "Density (Proportion)",
fill = "Citizen = 1",
color = "Citizen = 1") +
theme_minimal()
# Calculate median wage for each racial and citizenship group
median_data_race <- processed_data2 %>%
filter(RAC1P %in% c(1, 2, 6, 8, 9)) %>%
group_by(RAC1P, Citizen) %>%
summarise(median_wage = median(WAGP))
# Plot
wagerace <- ggplot(processed_data2 %>% filter(RAC1P %in% c(1, 2, 6, 8, 9)),
aes(x = WAGP, fill = factor(RAC1P), color = factor(RAC1P))) +
geom_density(aes(y = ..density..), alpha = 0.5) +
geom_vline(data = median_data_race, aes(xintercept = median_wage, color = factor(RAC1P)),
linetype = "dashed", linewidth = 0.5, alpha = 0.5) +
facet_wrap(vars(factor(Citizen))) +
labs(title = "Distribution of Wages by Race, Faceted by Citizenship Status",
x = "Wages Made in Last 12 Months",
y = "Density (Proportion)") +
theme_minimal()+
theme(axis.text.x = element_text(angle = 45, hjust = 1))
median_data_race <- processed_data2 %>%
filter(RAC1P %in% c(1, 2, 6)) %>%
group_by(RAC1P, Citizen) %>%
summarise(median_wage = median(WAGP))
wagerace2 <- ggplot(processed_data2 %>% filter(RAC1P %in% c(1, 2, 6)),
aes(x = WAGP, fill = factor(RAC1P), color = factor(RAC1P))) +
geom_density(aes(y = ..density..), alpha = 0.5) +
geom_vline(data = median_data_race, aes(xintercept = median_wage, color = factor(RAC1P)),
linetype = "dashed", linewidth = 0.5, alpha = 0.5) +
facet_wrap(vars(factor(Citizen))) +
labs(title = "Distribution of Wages by 3 Races, Faceted by Citizenship Status",
x = "Wages Made in Last 12 Months",
y = "Density (Proportion)") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Calculate median log(wage + 1) for the entire dataset
median_log_wage <- median(log(processed_data2$WAGP + 1))
# Plot
loga <- ggplot(processed_data2, aes(x = log(WAGP + 1), y = ..density..)) +
geom_density(color = 'cyan3', fill = 'cyan3', alpha = 0.5) +
geom_vline(xintercept = median_log_wage, linetype = "dashed", linewidth = 0.5, alpha = 0.5) +
labs(title = "Distribution of log(Wages + 1)",
x = "log(Wages + 1) Made in Last 12 Months")
# Calculate median log(wage + 1) for each citizenship group
median_data_citizen <- processed_data2 %>%
group_by(Citizen) %>%
summarise(median_log_wage = median(log(WAGP + 1)))
# Plot
logwagecit <- ggplot(processed_data2, aes(x = log(WAGP + 1), fill = factor(Citizen), color = factor(Citizen))) +
geom_density(aes(y = ..density..), alpha = 0.5) +
geom_vline(data = median_data_citizen, aes(xintercept = median_log_wage, color = factor(Citizen)),
linetype = "dashed", linewidth = 0.5, alpha = 0.5) +
labs(title = "Distribution of log(Wages + 1) by Citizenship Status",
x = "log(Wages + 1) Made in Last 12 Months",
y = "Density (Proportion)", fill = "Citizen", color = "Citizen") +
theme_minimal()
# Calculate median log(wage + 1) for each racial and citizenship group
median_data_race <- processed_data2 %>%
filter(RAC1P %in% c(1, 2, 6, 8, 9)) %>%
group_by(RAC1P, Citizen) %>%
summarise(median_log_wage = median(log(WAGP + 1)))
# Plot
logwagerace <- ggplot(processed_data2 %>% filter(RAC1P %in% c(1, 2, 6, 8, 9)),
aes(x = log(WAGP + 1), fill = factor(RAC1P), color = factor(RAC1P))) +
geom_density(aes(y = ..density..), alpha = 0.5) +
geom_vline(data = median_data_race, aes(xintercept = median_log_wage, color = factor(RAC1P)),
linetype = "dashed", linewidth = 0.5, alpha = 0.5) +
facet_wrap(vars(factor(Citizen))) +
labs(title = "Distribution of log(Wages + 1) by Race, Faceted by Citizenship Status",
x = "log(Wages + 1) Made in Last 12 Months",
y = "Density (Proportion)") +
theme_minimal()+
theme(axis.text.x = element_text(angle = 45, hjust = 1))
# Calculate median log(wage + 1) for each racial and citizenship group
median_data_race <- processed_data2 %>%
filter(RAC1P %in% c(1, 2, 6)) %>%
group_by(RAC1P, Citizen) %>%
summarise(median_log_wage = median(log(WAGP + 1)))
# Plot
logwagerace2 <- ggplot(processed_data2 %>% filter(RAC1P %in% c(1, 2, 6)),
aes(x = log(WAGP + 1), fill = factor(RAC1P), color = factor(RAC1P))) +
geom_density(aes(y = ..density..), alpha = 0.5) +
geom_vline(data = median_data_race, aes(xintercept = median_log_wage, color = factor(RAC1P)),
linetype = "dashed", linewidth = 0.5, alpha = 0.5) +
facet_wrap(vars(factor(Citizen))) +
labs(title = "Distribution of log(Wages + 1) by 3 Races, Faceted by Citizenship Status",
x = "log(Wages + 1) Made in Last 12 Months",
y = "Density (Proportion)") +
theme_minimal()+
theme(axis.text.x = element_text(angle = 45, hjust = 1))
grid.arrange(a, wagecit, wagerace, wagerace2, nrow = 2, ncol = 2)
grid.arrange(loga, logwagecit, logwagerace,logwagerace2, nrow = 2, ncol = 2)
# Step 1: List of independent variables (excluding ST)
independent_vars <- c("RAC1P", "AGEP", "SEX", "Citizen", "ENG",
"DIS", "wb50birth", "Unemployed",
"High_School_Grad", "Bachelors_Degree",
"HISP_dummy", "PAP", "HINS4", "MAR", "immigrant")
# One-hot encode selected categorical variables
processed_data_transformed <- processed_data2 %>%
mutate(across(c("RAC1P", "ENG", "MAR"), as.factor))%>%dplyr::select(all_of(independent_vars))
# One-hot encode selected categorical variables
processed_data_transformed<- processed_data_transformed%>%
dummyVars(~ ., data = ., fullRank = FALSE) %>%
predict(newdata = processed_data_transformed)
# Convert to data frame
processed_data_transformed <- as.data.frame(processed_data_transformed)
# Step 3: Calculate the correlation matrix
cor_matrix <- cor(processed_data_transformed, use = "complete.obs")
# Plot the correlation matrix with colors
corrplot(cor_matrix, method = "color",
addCoef.col = 'black', tl.cex = 0.45, number.cex = 0.4)
mini_model = lm(WAGP ~ as.factor(RAC1P) + AGEP +  SEX*Citizen + as.factor(ENG) + SEX*DIS + Unemployed  + wb50birth + as.factor(ST) + High_School_Grad  + Bachelors_Degree + HISP_dummy + PAP + HINS4 + as.factor(MAR), data = processed_data2)
# Get the summary of the model
summary_model <- summary(mini_model)
# Filter out rows related to state coefficients
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(summary_model$coefficients))
summary_model$coefficients <- summary_model$coefficients[!state_rows, ]
# Print the refined summary
# Extract R-squared and adjusted R-squared values
r_squared <- summary_model$r.squared
r_squared_adjusted <- summary_model$adj.r.squared
# Print the values with labels
cat("R-squared:", r_squared, "\n")
cat("Adjusted R-squared:", r_squared_adjusted, "\n")
# Function to compute EHW robust standard errors
compute_ehw_se <- function(model) {
robust_se <- sqrt(diag(vcovHC(model, type = "HC1")))
return(robust_se)
}
# Compute EHW robust standard errors
ehw_se <- compute_ehw_se(mini_model)
# Original coefficients, t-values, p-values, and confidence intervals
orig_summary <- summary(mini_model)
orig_coefficients <- coef(mini_model)
orig_t_values <- coef(orig_summary)[, "t value"]
orig_p_values <- coef(orig_summary)[, "Pr(>|t|)"]
orig_conf_intervals <- confint(mini_model)
# Calculate t-values using EHW standard errors
t_values_ehw <- orig_coefficients / ehw_se
# Calculate p-values using EHW standard errors
p_values_ehw <- 2 * pt(abs(t_values_ehw), df = mini_model$df.residual, lower.tail = FALSE)
# Calculate confidence bounds using EHW standard errors
conf_level <- 0.95 # 95% confidence level
crit_value <- qt(1 - (1 - conf_level) / 2, df = mini_model$df.residual)
conf_bounds_ehw <- cbind(orig_coefficients - crit_value * ehw_se,
orig_coefficients + crit_value * ehw_se)
# Create a logical vector to filter out coefficients related to "ST"
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(orig_summary$coefficients))
filter_vector <- !state_rows
# Filter out coefficients, t-values, p-values, and confidence bounds for "ST"
orig_coefficients <- orig_coefficients[filter_vector]
orig_t_values <- orig_t_values[filter_vector]
orig_p_values <- orig_p_values[filter_vector]
orig_conf_intervals <- orig_conf_intervals[filter_vector, ]
t_values_ehw <- t_values_ehw[filter_vector]
p_values_ehw <- p_values_ehw[filter_vector]
ehw_se <- ehw_se[filter_vector]
conf_bounds_ehw <- conf_bounds_ehw[filter_vector, ]
stars <- ifelse(orig_p_values < 0.001, "***",
ifelse(orig_p_values < 0.01, "**",
ifelse(orig_p_values < 0.05, "*",
ifelse(orig_p_values < 0.1, ".", ""))))
# Compute stars for significance based on EHW p-values
stars_ehw <- ifelse(p_values_ehw < 0.001, "***",
ifelse(p_values_ehw < 0.01, "**",
ifelse(p_values_ehw < 0.05, "*",
ifelse(p_values_ehw < 0.1, ".", ""))))
results <- data.frame(orig_coefficients, orig_t_values, orig_p_values, stars,
ehw_se, t_values_ehw, p_values_ehw, stars_ehw, conf_bounds_ehw)
rownames(results) <- names(orig_coefficients)
# Display results
print(results)
# Prepare data for plotting
plot_data <- data.frame(
Feature = rownames(results),
Coefficient = results$orig_coefficients,
SE = results$ehw_se,
Significance = results$stars
)
plot_data <- plot_data[order(plot_data$Coefficient), ]
plot_data$Feature <- factor(plot_data$Feature, levels = plot_data$Feature)
# Plot using ggplot
ggplot(plot_data, aes(x = Feature, y = Coefficient)) +
geom_point(aes(color = Significance), alpha = 0.5) +
geom_errorbar(aes(ymin = Coefficient - SE, ymax = Coefficient + SE, color = Significance), width = 0.6)  +
coord_flip() +
labs(title = "Coefficient Plot with EHW Robust Standard Errors",
subtitle = "Model (1): all respondents",
x = "Feature",
y = "Coefficient") +
theme_minimal() + theme(axis.text.y = element_text(size = 8))
# produce residual vs. fitted plot
plot(fitted(mini_model), resid(mini_model))
# add a horizontal line at 0
abline(0,0)
qqnorm(resid(mini_model))
qqline(resid(mini_model))
# produce residual vs. fitted plot
#plot(fitted(model0), resid(model0))
# add a horizontal line at 0
#abline(0,0)
# Plot
boxplot1<- ggplot(processed_data2%>%filter(RAC1P %in% c(1,2,6)), aes(x = factor(RAC1P),
y = WAGP,
color = factor(RAC1P))) +
geom_boxplot() +labs(x = "Racial Group", y = "Wages in YTD") + theme_minimal()
boxplot2 <-  ggplot(processed_data2%>%filter(RAC1P %in% c(1,2,6)), aes(x = factor(RAC1P),
y = log(WAGP + 1),
color = factor(RAC1P))) +
geom_boxplot() +labs(x = "Racial Group", y = "Wages in YTD") + theme_minimal()
grid.arrange(boxplot1, boxplot2, ncol = 2)
mini_model = lm(WAGP ~ as.factor(RAC1P) + AGEP +  SEX*Citizen + as.factor(ENG) + SEX*DIS + Unemployed + as.factor(ST) + wb50birth + High_School_Grad  + Bachelors_Degree + HISP_dummy + PAP + HINS4 + as.factor(MAR) + Years_in_US, data = immigrants_only2)
# Get the summary of the model
summary_model <- summary(mini_model)
# Filter out rows related to state coefficients
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(summary_model$coefficients))
summary_model$coefficients <- summary_model$coefficients[!state_rows, ]
# Print the refined summary
# Extract R-squared and adjusted R-squared values
r_squared <- summary_model$r.squared
r_squared_adjusted <- summary_model$adj.r.squared
# Print the values with labels
cat("R-squared:", r_squared, "\n")
cat("Adjusted R-squared:", r_squared_adjusted, "\n")
# Compute EHW robust standard errors
ehw_se <- compute_ehw_se(mini_model)
# Original coefficients, t-values, p-values, and confidence intervals
orig_summary <- summary(mini_model)
orig_coefficients <- coef(mini_model)
orig_t_values <- coef(orig_summary)[, "t value"]
orig_p_values <- coef(orig_summary)[, "Pr(>|t|)"]
orig_conf_intervals <- confint(mini_model)
# Calculate t-values using EHW standard errors
t_values_ehw <- orig_coefficients / ehw_se
# Calculate p-values using EHW standard errors
p_values_ehw <- 2 * pt(abs(t_values_ehw), df = mini_model$df.residual, lower.tail = FALSE)
# Calculate confidence bounds using EHW standard errors
conf_level <- 0.95 # 95% confidence level
crit_value <- qt(1 - (1 - conf_level) / 2, df = mini_model$df.residual)
conf_bounds_ehw <- cbind(orig_coefficients - crit_value * ehw_se,
orig_coefficients + crit_value * ehw_se)
# Create a logical vector to filter out coefficients related to "ST"
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(orig_summary$coefficients))
filter_vector <- !state_rows
# Filter out coefficients, t-values, p-values, and confidence bounds for "ST"
orig_coefficients <- orig_coefficients[filter_vector]
orig_t_values <- orig_t_values[filter_vector]
orig_p_values <- orig_p_values[filter_vector]
orig_conf_intervals <- orig_conf_intervals[filter_vector, ]
t_values_ehw <- t_values_ehw[filter_vector]
p_values_ehw <- p_values_ehw[filter_vector]
ehw_se <- ehw_se[filter_vector]
conf_bounds_ehw <- conf_bounds_ehw[filter_vector, ]
stars <- ifelse(orig_p_values < 0.001, "***",
ifelse(orig_p_values < 0.01, "**",
ifelse(orig_p_values < 0.05, "*",
ifelse(orig_p_values < 0.1, ".", ""))))
# Compute stars for significance based on EHW p-values
stars_ehw <- ifelse(p_values_ehw < 0.001, "***",
ifelse(p_values_ehw < 0.01, "**",
ifelse(p_values_ehw < 0.05, "*",
ifelse(p_values_ehw < 0.1, ".", ""))))
results <- data.frame(orig_coefficients, orig_t_values, orig_p_values, stars,
ehw_se, t_values_ehw, p_values_ehw, stars_ehw, conf_bounds_ehw)
rownames(results) <- names(orig_coefficients)
# Display results
print(results)
# Prepare data for plotting
plot_data <- data.frame(
Feature = rownames(results),
Coefficient = results$orig_coefficients,
SE = results$ehw_se,
Significance = results$stars
)
plot_data <- plot_data[order(plot_data$Coefficient), ]
plot_data$Feature <- factor(plot_data$Feature, levels = plot_data$Feature)
# Plot using ggplot
ggplot(plot_data, aes(x = Feature, y = Coefficient)) +
geom_point(aes(color = Significance), alpha = 0.5) +
geom_errorbar(aes(ymin = Coefficient - SE, ymax = Coefficient + SE, color = Significance), width = 0.6)  +
coord_flip() +
labs(title = "Coefficient Plot with EHW Robust Standard Errors",
subtitle = "Model (2): all Immigrants",
x = "Feature",
y = "Coefficient") +
theme_minimal() + theme(axis.text.y = element_text(size = 8))
mini_model = lm(WAGP ~ as.factor(RAC1P) + AGEP +  SEX*Citizen + as.factor(ENG) + SEX*DIS + Unemployed + as.factor(ST) + wb50birth + High_School_Grad  + Bachelors_Degree + HISP_dummy + PAP + HINS4 + as.factor(MAR), data = non_immigrants)
# Get the summary of the model
summary_model <- summary(mini_model)
# Filter out rows related to state coefficients
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(summary_model$coefficients))
summary_model$coefficients <- summary_model$coefficients[!state_rows, ]
# Print the refined summary
# Extract R-squared and adjusted R-squared values
r_squared <- summary_model$r.squared
r_squared_adjusted <- summary_model$adj.r.squared
# Print the values with labels
cat("R-squared:", r_squared, "\n")
cat("Adjusted R-squared:", r_squared_adjusted, "\n")
# Compute EHW robust standard errors
ehw_se <- compute_ehw_se(mini_model)
# Original coefficients, t-values, p-values, and confidence intervals
orig_summary <- summary(mini_model)
orig_coefficients <- coef(mini_model)
orig_t_values <- coef(orig_summary)[, "t value"]
orig_p_values <- coef(orig_summary)[, "Pr(>|t|)"]
orig_conf_intervals <- confint(mini_model)
# Calculate t-values using EHW standard errors
t_values_ehw <- orig_coefficients / ehw_se
# Calculate p-values using EHW standard errors
p_values_ehw <- 2 * pt(abs(t_values_ehw), df = mini_model$df.residual, lower.tail = FALSE)
# Calculate confidence bounds using EHW standard errors
conf_level <- 0.95 # 95% confidence level
crit_value <- qt(1 - (1 - conf_level) / 2, df = mini_model$df.residual)
conf_bounds_ehw <- cbind(orig_coefficients - crit_value * ehw_se,
orig_coefficients + crit_value * ehw_se)
# Create a logical vector to filter out coefficients related to "ST"
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(orig_summary$coefficients))
filter_vector <- !state_rows
# Filter out coefficients, t-values, p-values, and confidence bounds for "ST"
orig_coefficients <- orig_coefficients[filter_vector]
orig_t_values <- orig_t_values[filter_vector]
orig_p_values <- orig_p_values[filter_vector]
orig_conf_intervals <- orig_conf_intervals[filter_vector, ]
t_values_ehw <- t_values_ehw[filter_vector]
p_values_ehw <- p_values_ehw[filter_vector]
ehw_se <- ehw_se[filter_vector]
conf_bounds_ehw <- conf_bounds_ehw[filter_vector, ]
stars <- ifelse(orig_p_values < 0.001, "***",
ifelse(orig_p_values < 0.01, "**",
ifelse(orig_p_values < 0.05, "*",
ifelse(orig_p_values < 0.1, ".", ""))))
# Compute stars for significance based on EHW p-values
stars_ehw <- ifelse(p_values_ehw < 0.001, "***",
ifelse(p_values_ehw < 0.01, "**",
ifelse(p_values_ehw < 0.05, "*",
ifelse(p_values_ehw < 0.1, ".", ""))))
results <- data.frame(orig_coefficients, orig_t_values, orig_p_values, stars,
ehw_se, t_values_ehw, p_values_ehw, stars_ehw, conf_bounds_ehw)
mini_model = lm(WAGP ~ as.factor(RAC1P) + AGEP +  SEX*Citizen + as.factor(ENG) + SEX*DIS + Unemployed + as.factor(ST) + wb50birth + High_School_Grad  + Bachelors_Degree + HISP_dummy + PAP + HINS4 + as.factor(MAR), data = non_immigrants)
# Get the summary of the model
summary_model <- summary(mini_model)
# Filter out rows related to state coefficients
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(summary_model$coefficients))
summary_model$coefficients <- summary_model$coefficients[!state_rows, ]
# Print the refined summary
# Extract R-squared and adjusted R-squared values
r_squared <- summary_model$r.squared
r_squared_adjusted <- summary_model$adj.r.squared
# Print the values with labels
cat("R-squared:", r_squared, "\n")
cat("Adjusted R-squared:", r_squared_adjusted, "\n")
# Compute EHW robust standard errors
ehw_se <- compute_ehw_se(mini_model)
# Original coefficients, t-values, p-values, and confidence intervals
orig_summary <- summary(mini_model)
orig_coefficients <- coef(mini_model)
orig_t_values <- coef(orig_summary)[, "t value"]
orig_p_values <- coef(orig_summary)[, "Pr(>|t|)"]
orig_conf_intervals <- confint(mini_model)
# Calculate t-values using EHW standard errors
t_values_ehw <- orig_coefficients / ehw_se
# Calculate p-values using EHW standard errors
p_values_ehw <- 2 * pt(abs(t_values_ehw), df = mini_model$df.residual, lower.tail = FALSE)
# Calculate confidence bounds using EHW standard errors
conf_level <- 0.95 # 95% confidence level
crit_value <- qt(1 - (1 - conf_level) / 2, df = mini_model$df.residual)
conf_bounds_ehw <- cbind(orig_coefficients - crit_value * ehw_se,
orig_coefficients + crit_value * ehw_se)
# Create a logical vector to filter out coefficients related to "ST"
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(orig_summary$coefficients))
filter_vector <- !state_rows
# Filter out coefficients, t-values, p-values, and confidence bounds for "ST"
orig_coefficients <- orig_coefficients[filter_vector]
orig_t_values <- orig_t_values[filter_vector]
orig_p_values <- orig_p_values[filter_vector]
orig_conf_intervals <- orig_conf_intervals[filter_vector, ]
t_values_ehw <- t_values_ehw[filter_vector]
p_values_ehw <- p_values_ehw[filter_vector]
ehw_se <- ehw_se[filter_vector]
conf_bounds_ehw <- conf_bounds_ehw[filter_vector, ]
stars <- ifelse(orig_p_values < 0.001, "***",
ifelse(orig_p_values < 0.01, "**",
ifelse(orig_p_values < 0.05, "*",
ifelse(orig_p_values < 0.1, ".", ""))))
# Compute stars for significance based on EHW p-values
stars_ehw <- ifelse(p_values_ehw < 0.001, "***",
ifelse(p_values_ehw < 0.01, "**",
ifelse(p_values_ehw < 0.05, "*",
ifelse(p_values_ehw < 0.1, ".", ""))))
print(length(orig_coefficients))
print(length(orig_t_values))
print(length(orig_conf_intervals))
orig_coefficients
orig_coefficients[filter_vector]
