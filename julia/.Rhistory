data(fulntongen)
install.packages("/Users/juliaverdickt/Desktop/Berkeley_Stuff_MA/230A/Hw6/ri")
install.packages("/Users/juliaverdickt/Desktop/Berkeley_Stuff_MA/230A/Hw6/ri/ri_0.9.tar.gz", repos = NULL, type = "source")
install.packages("/Users/juliaverdickt/Desktop/Berkeley_Stuff_MA/230A/Hw6/ri_0.9.tar.gz", repos = NULL, type = "source")
# Load the ri package
library(ri)
# Load the dataset
data(fulntongen)
# Load the dataset
data('fulntongen')
# Load the ri package
library(ri)
# Load the dataset
data('fultongen')
# Load the dataset
data(fultongen)
# Load the dataset
data(fultongen)
data(package = "ri")
install.packages("ei")
# Load the ri package
library(ei)
data(package = "ei")
# Load the ri package
library(ei)
# Load the dataset
data(fultongen)
# Fit the OLS model
ols_fit <- lm(t ~ x, data = fulntongen)
# Fit the OLS model
ols_fit <- lm(t ~ x, data = fultongen)
# Fit the WLS model with weights being the total number of people 'n'
wls_fit <- lm(t ~ x, weights = n, data = fultongen)
# Extract the coefficients from both models for comparison
compare <- cbind(summary(ols_fit)$coef[, 1:3], summary(wls_fit)$coef[, 1:3])
# Print the comparison
print(compare)
# Print the comparison
round(compare, 3)
dat = read.csv ("samarani.csv")
pool.glm = glm(case_comb ~ ds1 + ds2 + ds3 + ds4_ a + ds4_b + ds5 + ds1_3 + center , family = binomial (link = logit), data = dat)
dat = read.csv ("samarani.csv")
pool.glm = glm(case_comb ~ ds1 + ds2 + ds3 + ds4_a + ds4_b + ds5 + ds1_3 + center , family = binomial (link = logit), data = dat)
summary(pool.glm)
dat$center <- as.factor(dat$center)
# Fit the model with interaction terms between center and other predictors
model_interaction <- glm(case_comb ~ (ds1 + ds2 + ds3 + ds4_a + ds4_b + ds5) * center, family=binomial(link="logit"), data=dat)
# View the summary of the model
summary(model_interaction)
dat$center <- as.factor(dat$center)
# List to store models
center_models <- list()
# Fit separate models for each center
levels_center <- levels(dat$center)
for(center in levels_center) {
center_data <- subset(dat, center == center)
center_models[[center]] <- glm(case_comb ~ ds1 + ds2 + ds3 + ds4_a + ds4_b + ds5,
family=binomial(link="logit"), data=center_data)
print(paste("Summary for center:", center))
print(summary(center_models[[center]]))
}
unique(dat$center)
library(tidyverse)
library(gridExtra)
library(MASS)
zip_file_path <- "../processed_data.zip"
csv_file_inside_zip <- "processed_data.csv"
processed_data <- read.csv(unz(zip_file_path, csv_file_inside_zip), header = TRUE,
sep = ",")
processed_data <- processed_data %>%
mutate(
DIS = ifelse(DIS == 2, 0, 1),
HINS4 = 1 - as.numeric(HINS4))
processed_data$ENG[is.na(processed_data$ENG)] <- 0
colnames(processed_data)
processed_data$Years_naturalized[processed_data$Foreign_born == 0] <- 0
processed_data$Years_in_US[processed_data$Foreign_born == 0] <- 0
processed_data$Years_naturalized[processed_data$CIT == 5] <- 0
processed_data = processed_data%>%filter(CIT != 2)
processed_data$wb50birth <- processed_data$FER
processed_data$wb50birth[is.na(processed_data$FER) &
(processed_data$AGEP >= 50 | processed_data$SEX == 0)] <- 0
#colSums(is.na(processed_data))
processed_data2 = processed_data%>%filter(WAGP>0)
processed_data2$adj_WAGP = log(processed_data2$WAGP)
# Using the boxcox function to determine the best lambda
bc_outcome <- boxcox(WAGP ~ 1, data = processed_data2, lambda = seq(-2, 2, length = 100))
# Plotting to visually inspect the best lambda
plot(bc_outcome)
# Finding the lambda that maximizes the log-likelihood
best_lambda <- bc_outcome$x[which.max(bc_outcome$y)]
# Applying the Box-Cox transformation
processed_data2 <- processed_data2 %>%
mutate(bc_WAGP = ifelse(best_lambda != 0,
(WAGP^best_lambda - 1) / best_lambda,
log(WAGP)))
a <- ggplot(processed_data2,aes(x = WAGP)) + geom_histogram()
b <- ggplot(processed_data2,aes(x = adj_WAGP)) + geom_histogram()
grid.arrange(a,b, ncol = 2)
wagecit<- ggplot(processed_data2, aes(x = WAGP, fill = factor(Citizen), color = factor(Citizen))) +
geom_density(aes(y = ..density..), alpha = 0.5) +
labs(title = "Distribution of Wages by Race",
x = "Wages",
y = "Density (Proportion)") + theme_minimal()
wagecit
logwagecit<- ggplot(processed_data2, aes(x = adj_WAGP, fill = factor(Citizen), color = factor(Citizen))) +
geom_density(aes(y = ..density..), alpha = 0.5) +
labs(title = "Distribution of log(Wages + 1) by Race",
x = "log(Wages + 1)",
y = "Density (Proportion)") + theme_minimal()
wagerace<- ggplot(processed_data2, aes(x = WAGP, fill = factor(RAC1P), color = factor(RAC1P))) +
geom_density(aes(y = ..density..), alpha = 0.5) +
facet_wrap(vars(factor(Citizen))) +
labs(title = "Distribution of Wages by Race, Faceted by Citizenship Status",
x = "Wages",
y = "Density (Proportion)") + theme_minimal()
logwagerace<- processed_data2%>%filter(RAC1P %in% c(1,2,6))%>%ggplot(aes(x = adj_WAGP, fill = factor(RAC1P), color = factor(RAC1P))) +
geom_density(aes(y = ..density..), alpha = 0.5) +
facet_wrap(vars(factor(Citizen))) +
labs(title = "Distribution of log(Wages + 1) by Race, Faceted by Citizenship Status",
x = "log(Wages + 1)",
y = "Density (Proportion)") + theme_minimal()
logwage_for<- processed_data2%>%filter(RAC1P %in% c(1,2,6,8,9))%>%ggplot(aes(x = adj_WAGP)) +
geom_density(aes(y = ..density.., fill = factor(RAC1P), color = factor(RAC1P)), alpha = 0.5) +
facet_wrap(vars(factor(Foreign_born))) +
labs(title = "Distribution of log(Wages + 1) by Race, Faceted by Foreign_born",
x = "log(Wages + 1)",
y = "Density (Proportion)") + theme_minimal()
processed_data2 = processed_data2%>%mutate(immigrant = CIT%in%c(4,5))
model0 = lm(adj_WAGP ~as.factor(RAC1P) + AGEP + SEX*Citizen + as.factor(ENG) + SEX*DIS + wb50birth+ Unemployed + as.factor(ST) + High_School_Grad + Bachelors_Degree + HISP_dummy + PAP + HINS4 + immigrant, data = processed_data2)
# Get the summary of the model
summary_model <- summary(model0)
# Filter out rows related to state coefficients
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(summary_model$coefficients))
summary_model$coefficients <- summary_model$coefficients[!state_rows, ]
# Print the refined summary
summary_model
qqnorm(resid(model0))
qqline(resid(model0))
# produce residual vs. fitted plot
plot(fitted(model0), resid(model0))
# add a horizontal line at 0
abline(0,0)
model0.1 = lm(bc_WAGP ~as.factor(RAC1P) + AGEP + SEX*Citizen + as.factor(ENG) + SEX*DIS + wb50birth+ Unemployed + as.factor(ST) + High_School_Grad + Bachelors_Degree + HISP_dummy + PAP + HINS4 + immigrant, data = processed_data2)
# Get the summary of the model
summary_model <- summary(model0.1)
# Filter out rows related to state coefficients
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(summary_model$coefficients))
summary_model$coefficients <- summary_model$coefficients[!state_rows, ]
# Print the refined summary
summary_model
qqnorm(resid(model0.1))
qqline(resid(model0.1))
# produce residual vs. fitted plot
plot(fitted(model0.1), resid(model0.1))
# add a horizontal line at 0
abline(0,0)
processed_data2$bc_WAGP
processed_data2%>%group_by(bc_WAGP)%>%summarise(n())
# Applying the Box-Cox transformation
processed_data2 <- processed_data2 %>%
mutate(bc_WAGP = ifelse(best_lambda != 0,
(WAGP^best_lambda - 1) / best_lambda,
log(WAGP)))
processed_data2%>%group_by(bc_WAGP)%>%summarise(n())
library(tidyverse)
library(gridExtra)
library(MASS)
zip_file_path <- "../processed_data.zip"
csv_file_inside_zip <- "processed_data.csv"
processed_data <- read.csv(unz(zip_file_path, csv_file_inside_zip), header = TRUE,
sep = ",")
processed_data <- processed_data %>%
mutate(
DIS = ifelse(DIS == 2, 0, 1),
HINS4 = 1 - as.numeric(HINS4))
processed_data$ENG[is.na(processed_data$ENG)] <- 0
colnames(processed_data)
processed_data$Years_naturalized[processed_data$Foreign_born == 0] <- 0
processed_data$Years_in_US[processed_data$Foreign_born == 0] <- 0
processed_data$Years_naturalized[processed_data$CIT == 5] <- 0
processed_data = processed_data%>%filter(CIT != 2)
processed_data$wb50birth <- processed_data$FER
processed_data$wb50birth[is.na(processed_data$FER) &
(processed_data$AGEP >= 50 | processed_data$SEX == 0)] <- 0
#colSums(is.na(processed_data))
processed_data2 = processed_data%>%filter(WAGP>0)
processed_data2$adj_WAGP = log(processed_data2$WAGP)
# Using the boxcox function to determine the best lambda
bc_outcome <- boxcox(WAGP ~ 1, data = processed_data2, lambda = seq(-2, 2, length = 100))
# Plotting to visually inspect the best lambda
plot(bc_outcome)
# Finding the lambda that maximizes the log-likelihood
best_lambda <- bc_outcome$x[which.max(bc_outcome$y)]
# Applying the Box-Cox transformation
processed_data2 <- processed_data2 %>%
mutate(bc_WAGP = ifelse(best_lambda != 0,
(WAGP^best_lambda - 1) / best_lambda,
log(WAGP)))
# Applying the Box-Cox transformation
processed_data2 <- processed_data2 %>%
mutate(bc_WAGP = ifelse(best_lambda != 0,
(WAGP^best_lambda - 1) / best_lambda,
log(WAGP)))
processed_data2%>%group_by(bc_WAGP)%>%summarise(n())
# Applying the Box-Cox transformation
processed_data2 <- processed_data2 %>%
mutate(bc_WAGP = (WAGP^best_lambda - 1) / best_lambda)
processed_data2%>%group_by(bc_WAGP)%>%summarise(n())
best_lambda
# Applying the Box-Cox transformation
processed_data2$bc_WAGP <- if(best_lambda != 0) {
(processed_data2$WAGP^best_lambda - 1) / best_lambda
} else {
log(processed_data2$WAGP)
}
processed_data2%>%group_by(bc_WAGP)%>%summarise(n())
model0.1 = lm(bc_WAGP ~as.factor(RAC1P) + AGEP + SEX*Citizen + as.factor(ENG) + SEX*DIS + wb50birth+ Unemployed + as.factor(ST) + High_School_Grad + Bachelors_Degree + HISP_dummy + PAP + HINS4 + immigrant, data = processed_data2)
processed_data2 = processed_data2%>%mutate(immigrant = CIT%in%c(4,5))
model0.1 = lm(bc_WAGP ~as.factor(RAC1P) + AGEP + SEX*Citizen + as.factor(ENG) + SEX*DIS + wb50birth+ Unemployed + as.factor(ST) + High_School_Grad + Bachelors_Degree + HISP_dummy + PAP + HINS4 + immigrant, data = processed_data2)
# Get the summary of the model
summary_model <- summary(model0.1)
# Filter out rows related to state coefficients
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(summary_model$coefficients))
summary_model$coefficients <- summary_model$coefficients[!state_rows, ]
# Print the refined summary
summary_model
qqnorm(resid(model0.1))
qqline(resid(model0.1))
# produce residual vs. fitted plot
plot(fitted(model0.1), resid(model0.1))
# add a horizontal line at 0
abline(0,0)
# Using the boxcox function to determine the best lambda
bc_outcome <- boxcox(WAGP ~ 1, data = processed_data2, lambda = seq(-2, 2, by = 0.1))
# Plotting to visually inspect the best lambda
plot(bc_outcome)
# Finding the lambda that maximizes the log-likelihood
best_lambda <- bc_outcome$x[which.max(bc_outcome$y)]
# Using the boxcox function to determine the best lambda
bc_outcome <- boxcox(WAGP ~ 1, data = processed_data2, lambda = seq(-2, 2, by = 0.01))
# Plotting to visually inspect the best lambda
plot(bc_outcome)
# Finding the lambda that maximizes the log-likelihood
best_lambda <- bc_outcome$x[which.max(bc_outcome$y)]
print(best_lambda)
# Using the boxcox function to determine the best lambda
bc_outcome <- boxcox(WAGP ~ 1, data = processed_data2, lambda = seq(-6, 6, by = 0.1))
# Plotting to visually inspect the best lambda
plot(bc_outcome)
# Finding the lambda that maximizes the log-likelihood
best_lambda <- bc_outcome$x[which.max(bc_outcome$y)]
print(best_lambda)
# Applying the Box-Cox transformation
processed_data2$bc_WAGP <- if(best_lambda != 0) {
(processed_data2$WAGP^best_lambda - 1) / best_lambda
} else {
log(processed_data2$WAGP)
}
processed_data2 = processed_data2%>%mutate(immigrant = CIT%in%c(4,5))
model0.1 = lm(bc_WAGP ~as.factor(RAC1P) + AGEP + SEX*Citizen + as.factor(ENG) + SEX*DIS + wb50birth+ Unemployed + as.factor(ST) + High_School_Grad + Bachelors_Degree + HISP_dummy + PAP + HINS4 + immigrant, data = processed_data2)
# Get the summary of the model
summary_model <- summary(model0.1)
# Filter out rows related to state coefficients
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(summary_model$coefficients))
summary_model$coefficients <- summary_model$coefficients[!state_rows, ]
# Print the refined summary
summary_model
qqnorm(resid(model0.1))
qqline(resid(model0.1))
# produce residual vs. fitted plot
plot(fitted(model0.1), resid(model0.1))
# add a horizontal line at 0
abline(0,0)
model0 = lm(adj_WAGP ~as.factor(RAC1P) + AGEP + SEX*Citizen + as.factor(ENG) + SEX*DIS + wb50birth+ Unemployed + as.factor(ST) + High_School_Grad + Bachelors_Degree + HISP_dummy + PAP + HINS4 + immigrant, data = processed_data2)
# Get the summary of the model
summary_model <- summary(model0)
# Filter out rows related to state coefficients
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(summary_model$coefficients))
summary_model$coefficients <- summary_model$coefficients[!state_rows, ]
# Print the refined summary
summary_model
qqnorm(resid(model0))
qqline(resid(model0))
# produce residual vs. fitted plot
plot(fitted(model0), resid(model0))
# add a horizontal line at 0
abline(0,0)
plot(adj_WAGP, AGEP)
plot(processed_data2$adj_WAGP, processed_data2$AGEP)
plot(processed_data2$AGEP, processed_data2$adj_WAGP)
model0 = lm(adj_WAGP ~as.factor(RAC1P) + AGEP + I(AGEP^2) + SEX*Citizen + as.factor(ENG) + SEX*DIS + wb50birth+ Unemployed + as.factor(ST) + High_School_Grad + Bachelors_Degree + HISP_dummy + PAP + HINS4 + immigrant, data = processed_data2)
# Get the summary of the model
summary_model <- summary(model0)
# Filter out rows related to state coefficients
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(summary_model$coefficients))
summary_model$coefficients <- summary_model$coefficients[!state_rows, ]
# Print the refined summary
summary_model
qqnorm(resid(model0))
qqline(resid(model0))
plot(processed_data2$PAP, processed_data2$adj_WAGP)
qqnorm(resid(model0))
qqline(resid(model0))
model0 = lm(adj_WAGP ~as.factor(RAC1P) + AGEP + I(AGEP^2) + SEX*Citizen + as.factor(ENG) + SEX*DIS + wb50birth + as.factor(ST) + High_School_Grad + Bachelors_Degree + HISP_dummy + PAP + I(PAP^2) + HINS4 + immigrant, data = processed_data2)
qqnorm(resid(model0))
qqline(resid(model0))
# Get the summary of the model
summary_model <- summary(model0)
# Filter out rows related to state coefficients
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(summary_model$coefficients))
summary_model$coefficients <- summary_model$coefficients[!state_rows, ]
# Print the refined summary
summary_model
model0 = lm(adj_WAGP ~as.factor(RAC1P) + AGEP + I(AGEP^2) + SEX*Citizen + as.factor(ENG) + SEX*DIS + wb50birth + as.factor(ST) + High_School_Grad + Bachelors_Degree + HISP_dummy + PAP + HINS4 + immigrant, data = processed_data2)
residuals_df <- data.frame(residuals = resid(model0))
ggplot(residuals_df, aes(sample = residuals)) +
stat_qq() +
stat_qq_line(color = "red") +
ggtitle("Normal Q-Q Plot of Residuals") +
xlab("Theoretical Quantiles") +
ylab("Sample Quantiles") +
theme_minimal() +
theme(aspect.ratio = 1)
library(tidyverse)
library(gridExtra)
library(MASS)
zip_file_path <- "../processed_data.zip"
csv_file_inside_zip <- "processed_data.csv"
processed_data <- read.csv(unz(zip_file_path, csv_file_inside_zip), header = TRUE,
sep = ",")
processed_data <- processed_data %>%
mutate(
DIS = ifelse(DIS == 2, 0, 1),
HINS4 = 1 - as.numeric(HINS4))
processed_data$ENG[is.na(processed_data$ENG)] <- 0
colnames(processed_data)
processed_data$Years_naturalized[processed_data$Foreign_born == 0] <- 0
processed_data$Years_in_US[processed_data$Foreign_born == 0] <- 0
processed_data$Years_naturalized[processed_data$CIT == 5] <- 0
processed_data = processed_data%>%filter(CIT != 2)
processed_data$wb50birth <- processed_data$FER
processed_data$wb50birth[is.na(processed_data$FER) &
(processed_data$AGEP >= 50 | processed_data$SEX == 0)] <- 0
#colSums(is.na(processed_data))
processed_data2 = processed_data%>%filter(WAGP>0 & WAGP < 999999)
processed_data2$adj_WAGP = log(processed_data2$WAGP)
# Using the boxcox function to determine the best lambda
bc_outcome <- boxcox(WAGP ~ 1, data = processed_data2, lambda = seq(-6, 6, by = 0.1))
# Plotting to visually inspect the best lambda
plot(bc_outcome)
# Finding the lambda that maximizes the log-likelihood
best_lambda <- bc_outcome$x[which.max(bc_outcome$y)]
print(best_lambda)
# Applying the Box-Cox transformation
processed_data2$bc_WAGP <- if(best_lambda != 0) {
(processed_data2$WAGP^best_lambda - 1) / best_lambda
} else {
log(processed_data2$WAGP)
}
a <- ggplot(processed_data2,aes(x = WAGP)) + geom_histogram()
b <- ggplot(processed_data2,aes(x = adj_WAGP)) + geom_histogram()
grid.arrange(a,b, ncol = 2)
wagecit<- ggplot(processed_data2, aes(x = WAGP, fill = factor(Citizen), color = factor(Citizen))) +
geom_density(aes(y = ..density..), alpha = 0.5) +
labs(title = "Distribution of Wages by Race",
x = "Wages",
y = "Density (Proportion)") + theme_minimal()
wagecit
logwagecit<- ggplot(processed_data2, aes(x = adj_WAGP, fill = factor(Citizen), color = factor(Citizen))) +
geom_density(aes(y = ..density..), alpha = 0.5) +
labs(title = "Distribution of log(Wages + 1) by Race",
x = "log(Wages + 1)",
y = "Density (Proportion)") + theme_minimal()
wagerace<- ggplot(processed_data2, aes(x = WAGP, fill = factor(RAC1P), color = factor(RAC1P))) +
geom_density(aes(y = ..density..), alpha = 0.5) +
facet_wrap(vars(factor(Citizen))) +
labs(title = "Distribution of Wages by Race, Faceted by Citizenship Status",
x = "Wages",
y = "Density (Proportion)") + theme_minimal()
logwagerace<- processed_data2%>%filter(RAC1P %in% c(1,2,6))%>%ggplot(aes(x = adj_WAGP, fill = factor(RAC1P), color = factor(RAC1P))) +
geom_density(aes(y = ..density..), alpha = 0.5) +
facet_wrap(vars(factor(Citizen))) +
labs(title = "Distribution of log(Wages + 1) by Race, Faceted by Citizenship Status",
x = "log(Wages + 1)",
y = "Density (Proportion)") + theme_minimal()
logwage_for<- processed_data2%>%filter(RAC1P %in% c(1,2,6,8,9))%>%ggplot(aes(x = adj_WAGP)) +
geom_density(aes(y = ..density.., fill = factor(RAC1P), color = factor(RAC1P)), alpha = 0.5) +
facet_wrap(vars(factor(Foreign_born))) +
labs(title = "Distribution of log(Wages + 1) by Race, Faceted by Foreign_born",
x = "log(Wages + 1)",
y = "Density (Proportion)") + theme_minimal()
processed_data2 = processed_data2%>%mutate(immigrant = CIT%in%c(4,5))
model0 = lm(adj_WAGP ~as.factor(RAC1P) + AGEP + I(AGEP^2) + SEX*Citizen + as.factor(ENG) + SEX*DIS + wb50birth + as.factor(ST) + High_School_Grad + Bachelors_Degree + HISP_dummy + PAP + HINS4 + immigrant, data = processed_data2)
# Get the summary of the model
summary_model <- summary(model0)
# Filter out rows related to state coefficients
state_rows <- grepl("^as\\.factor\\(ST\\)", rownames(summary_model$coefficients))
summary_model$coefficients <- summary_model$coefficients[!state_rows, ]
# Print the refined summary
summary_model
residuals_df <- data.frame(residuals = resid(model0))
ggplot(residuals_df, aes(sample = residuals)) +
stat_qq() +
stat_qq_line(color = "red") +
ggtitle("Normal Q-Q Plot of Residuals") +
xlab("Theoretical Quantiles") +
ylab("Sample Quantiles") +
theme_minimal() +
theme(aspect.ratio = 1)
qqnorm(resid(model0))
qqline(resid(model0))
library(tidyverse)
library(gridExtra)
library(MASS)
library(corrplot)
library(sandwich)
library(caret)
library(boot)
library(future.apply)
zip_file_path <- "../processed_data.zip"
csv_file_inside_zip <- "processed_data.csv"
processed_data <- read.csv(unz(zip_file_path, csv_file_inside_zip), header = TRUE,
sep = ",")
processed_data <- processed_data %>%
mutate(
DIS = ifelse(DIS == 2, 0, 1),
HINS4 = 1 - as.numeric(HINS4),
High_School_Grad = ifelse(SCHL >= 16, 1, 0))
processed_data$ENG[is.na(processed_data$ENG)] <- 0
#colnames(processed_data)
processed_data$Years_naturalized[processed_data$Foreign_born == 0] <- 0
processed_data$Years_in_US[processed_data$Foreign_born == 0] <- 0
processed_data$Years_naturalized[processed_data$CIT == 5] <- 0
processed_data = processed_data%>%filter(CIT != 2)
processed_data$wb50birth <- processed_data$FER
processed_data$wb50birth[is.na(processed_data$FER) &
(processed_data$AGEP >= 50 | processed_data$SEX == 0)] <- 0
#colSums(is.na(processed_data))
processed_data2 = processed_data%>%filter(!(WAGP == 0 & Unemployed == 0))
processed_data2 = processed_data2%>%mutate(immigrant = as.integer(CIT%in%c(4,5)))
processed_data2 <- processed_data2%>%mutate(white_dummy = (RAC1P == 1),
asian_dummy = (RAC1P == 6),
black_dummy = (RAC1P == 2))
immigrants_only = processed_data2%>%filter(CIT%in% c(4,5))
immigrants_only2 = immigrants_only%>%filter(RAC1P%in%c(1,2,6,8,9))
non_immigrants = processed_data2%>%filter(immigrant==1, RAC1P%in%c(1,2,6,8,9))
install.packages("pbsapply")
install.packages("pbapply")
library(pbapply)
# Function to compute bootstrap standard errors, confidence intervals, and p-values
compute_bootstrap_results <- function(model_formula, data, B = 50, conf_level = 0.95,
verbose = TRUE) {
# Function to fit the model and extract coefficients
boot_fn <- function(data, indices) {
boot_sample <- data[indices, ]
fit <- lm(model_formula, data = boot_sample)
return(coef(fit))
}
# Perform bootstrap
#results <- boot(data, boot_fn, R = B)
# Number of cores to use
#num_cores <- parallel::detectCores() - 1
#cl <- parallel::makeCluster(num_cores, type = ifelse(.Platform$OS.type == "windows", "PSOCK", "FORK"))
# Perform bootstrap
#results <- boot(data, boot_fn, R = B, parallel = "snow", ncpus = num_cores, cl = cl)
#parallel::stopCluster(cl)
# Perform bootstrap
# Setup parallelization based on the system
num_cores <- parallel::detectCores() - 1
parallel_type <- ifelse(.Platform$OS.type == "windows", "snow", "multicore")
if (verbose) {
# Perform bootstrap with progress bar
results <- pbsapply(1:B, function(i) {
boot(data, boot_fn, R = 1, parallel = parallel_type, ncpus = num_cores)
}, cl = num_cores)
results <- do.call(rbind, lapply(results, function(x) x$t))
results <- list(t = results)
} else {
# Perform bootstrap without progress bar
results <- boot(data, boot_fn, R = B, parallel = parallel_type, ncpus = num_cores)
}
# Calculate means and standard errors
boot_means <- colMeans(results$t)
boot_se <- apply(results$t, 2, function(x) sqrt(mean((x - boot_means)^2)))
# Compute standard errors
#boot_se <- apply(results$t, 2, function(x) sqrt(mean((x - mean(x))^2)))
# Compute confidence intervals
conf_bounds <- apply(results$t, 2, function(x) quantile(x, c((1 - conf_level) / 2, 1 - (1 - conf_level) / 2)))
# Get original coefficients
original_coefs <- coef(lm(model_formula, data = data))
p_values <- sapply(1:ncol(results$t), function(i) {
mean(abs(results$t[, i]) > abs(original_coefs[i]))
})
# Compute stars for significance
stars <- ifelse(p_values < 0.001, "***",
ifelse(p_values < 0.01, "**",
ifelse(p_values < 0.05, "*",
ifelse(p_values < 0.1, ".", ""))))
return(list(boot_se = boot_se,
conf_bounds = conf_bounds,
p_values = p_values,
stars = stars))
}
# Original model formula
model_formula <- WAGP ~ as.factor(RAC1P) + AGEP +  SEX*Citizen + as.factor(ENG) + SEX*DIS + Unemployed + as.factor(ST) + High_School_Grad  + Bachelors_Degree + HISP_dummy + PAP + HINS4 + as.factor(MAR)
# Apply the function to the mini_model
results <- compute_bootstrap_results(model_formula, processed_data2)
# Original model formula
model_formula <- WAGP ~ as.factor(RAC1P) + AGEP +  SEX*Citizen + as.factor(ENG) + SEX*DIS + Unemployed + as.factor(ST) + High_School_Grad  + Bachelors_Degree + HISP_dummy + PAP + HINS4 + as.factor(MAR)
# Apply the function to the mini_model
results <- compute_bootstrap_results(model_formula, processed_data2)
